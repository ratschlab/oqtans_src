The system is: Linux - 2.6.32-308-ec2 - x86_64
Compiling the C compiler identification source file "CMakeCCompilerId.c" succeeded.
Compiler: /usr/bin/gcc 
Build flags: 
Id flags: 

The output was:
0


Compilation of the C compiler identification source "CMakeCCompilerId.c" produced "a.out"

The C compiler identification is GNU, found in "/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CompilerIdC/a.out"

Compiling the CXX compiler identification source file "CMakeCXXCompilerId.cpp" succeeded.
Compiler: /usr/bin/g++ 
Build flags: 
Id flags: 

The output was:
0


Compilation of the CXX compiler identification source "CMakeCXXCompilerId.cpp" produced "a.out"

The CXX compiler identification is GNU, found in "/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CompilerIdCXX/a.out"

Determining if the C compiler works passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec343154759/fast"
make -f CMakeFiles/cmTryCompileExec343154759.dir/build.make CMakeFiles/cmTryCompileExec343154759.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec343154759.dir/testCCompiler.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec343154759.dir/testCCompiler.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/testCCompiler.c
Linking C executable cmTryCompileExec343154759
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec343154759.dir/link.txt --verbose=1
/usr/bin/gcc         CMakeFiles/cmTryCompileExec343154759.dir/testCCompiler.c.o  -o cmTryCompileExec343154759 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Detecting C compiler ABI info compiled with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1948335347/fast"
make -f CMakeFiles/cmTryCompileExec1948335347.dir/build.make CMakeFiles/cmTryCompileExec1948335347.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1948335347.dir/CMakeCCompilerABI.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec1948335347.dir/CMakeCCompilerABI.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Modules/CMakeCCompilerABI.c
Linking C executable cmTryCompileExec1948335347
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1948335347.dir/link.txt --verbose=1
/usr/bin/gcc       -v CMakeFiles/cmTryCompileExec1948335347.dir/CMakeCCompilerABI.c.o  -o cmTryCompileExec1948335347 -rdynamic  
Using built-in specs.
Target: x86_64-linux-gnu
Configured with: ../src/configure -v --with-pkgversion='Ubuntu 4.4.3-4ubuntu5' --with-bugurl=file:///usr/share/doc/gcc-4.4/README.Bugs --enable-languages=c,c++,fortran,objc,obj-c++ --prefix=/usr --enable-shared --enable-multiarch --enable-linker-build-id --with-system-zlib --libexecdir=/usr/lib --without-included-gettext --enable-threads=posix --with-gxx-include-dir=/usr/include/c++/4.4 --program-suffix=-4.4 --enable-nls --enable-clocale=gnu --enable-libstdcxx-debug --enable-plugin --enable-objc-gc --disable-werror --with-arch-32=i486 --with-tune=generic --enable-checking=release --build=x86_64-linux-gnu --host=x86_64-linux-gnu --target=x86_64-linux-gnu
Thread model: posix
gcc version 4.4.3 (Ubuntu 4.4.3-4ubuntu5) 
COMPILER_PATH=/usr/lib/gcc/x86_64-linux-gnu/4.4.3/:/usr/lib/gcc/x86_64-linux-gnu/4.4.3/:/usr/lib/gcc/x86_64-linux-gnu/:/usr/lib/gcc/x86_64-linux-gnu/4.4.3/:/usr/lib/gcc/x86_64-linux-gnu/:/usr/lib/gcc/x86_64-linux-gnu/4.4.3/:/usr/lib/gcc/x86_64-linux-gnu/
LIBRARY_PATH=/usr/lib/gcc/x86_64-linux-gnu/4.4.3/:/usr/lib/gcc/x86_64-linux-gnu/4.4.3/:/usr/lib/gcc/x86_64-linux-gnu/4.4.3/../../../../lib/:/lib/../lib/:/usr/lib/../lib/:/usr/lib/gcc/x86_64-linux-gnu/4.4.3/../../../:/lib/:/usr/lib/
COLLECT_GCC_OPTIONS='-v' '-o' 'cmTryCompileExec1948335347' '-rdynamic' '-mtune=generic'
 /usr/lib/gcc/x86_64-linux-gnu/4.4.3/collect2 --build-id --eh-frame-hdr -m elf_x86_64 --hash-style=both -export-dynamic -dynamic-linker /lib64/ld-linux-x86-64.so.2 -o cmTryCompileExec1948335347 -z relro /usr/lib/gcc/x86_64-linux-gnu/4.4.3/../../../../lib/crt1.o /usr/lib/gcc/x86_64-linux-gnu/4.4.3/../../../../lib/crti.o /usr/lib/gcc/x86_64-linux-gnu/4.4.3/crtbegin.o -L/usr/lib/gcc/x86_64-linux-gnu/4.4.3 -L/usr/lib/gcc/x86_64-linux-gnu/4.4.3 -L/usr/lib/gcc/x86_64-linux-gnu/4.4.3/../../../../lib -L/lib/../lib -L/usr/lib/../lib -L/usr/lib/gcc/x86_64-linux-gnu/4.4.3/../../.. CMakeFiles/cmTryCompileExec1948335347.dir/CMakeCCompilerABI.c.o -lgcc --as-needed -lgcc_s --no-as-needed -lc -lgcc --as-needed -lgcc_s --no-as-needed /usr/lib/gcc/x86_64-linux-gnu/4.4.3/crtend.o /usr/lib/gcc/x86_64-linux-gnu/4.4.3/../../../../lib/crtn.o
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Parsed C implicit link information from above output:
  link line regex: [^( *|.*[/\])(ld|ld|collect2)[^/\]*( |$)]
  ignore line: [Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp]
  ignore line: []
  ignore line: [Run Build Command:/usr/bin/make "cmTryCompileExec1948335347/fast"]
  ignore line: [make -f CMakeFiles/cmTryCompileExec1948335347.dir/build.make CMakeFiles/cmTryCompileExec1948335347.dir/build]
  ignore line: [make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp']
  ignore line: [/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1]
  ignore line: [Building C object CMakeFiles/cmTryCompileExec1948335347.dir/CMakeCCompilerABI.c.o]
  ignore line: [/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec1948335347.dir/CMakeCCompilerABI.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Modules/CMakeCCompilerABI.c]
  ignore line: [Linking C executable cmTryCompileExec1948335347]
  ignore line: [/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1948335347.dir/link.txt --verbose=1]
  ignore line: [/usr/bin/gcc       -v CMakeFiles/cmTryCompileExec1948335347.dir/CMakeCCompilerABI.c.o  -o cmTryCompileExec1948335347 -rdynamic  ]
  ignore line: [Using built-in specs.]
  ignore line: [Target: x86_64-linux-gnu]
  ignore line: [Configured with: ../src/configure -v --with-pkgversion='Ubuntu 4.4.3-4ubuntu5' --with-bugurl=file:///usr/share/doc/gcc-4.4/README.Bugs --enable-languages=c,c++,fortran,objc,obj-c++ --prefix=/usr --enable-shared --enable-multiarch --enable-linker-build-id --with-system-zlib --libexecdir=/usr/lib --without-included-gettext --enable-threads=posix --with-gxx-include-dir=/usr/include/c++/4.4 --program-suffix=-4.4 --enable-nls --enable-clocale=gnu --enable-libstdcxx-debug --enable-plugin --enable-objc-gc --disable-werror --with-arch-32=i486 --with-tune=generic --enable-checking=release --build=x86_64-linux-gnu --host=x86_64-linux-gnu --target=x86_64-linux-gnu]
  ignore line: [Thread model: posix]
  ignore line: [gcc version 4.4.3 (Ubuntu 4.4.3-4ubuntu5) ]
  ignore line: [COMPILER_PATH=/usr/lib/gcc/x86_64-linux-gnu/4.4.3/:/usr/lib/gcc/x86_64-linux-gnu/4.4.3/:/usr/lib/gcc/x86_64-linux-gnu/:/usr/lib/gcc/x86_64-linux-gnu/4.4.3/:/usr/lib/gcc/x86_64-linux-gnu/:/usr/lib/gcc/x86_64-linux-gnu/4.4.3/:/usr/lib/gcc/x86_64-linux-gnu/]
  ignore line: [LIBRARY_PATH=/usr/lib/gcc/x86_64-linux-gnu/4.4.3/:/usr/lib/gcc/x86_64-linux-gnu/4.4.3/:/usr/lib/gcc/x86_64-linux-gnu/4.4.3/../../../../lib/:/lib/../lib/:/usr/lib/../lib/:/usr/lib/gcc/x86_64-linux-gnu/4.4.3/../../../:/lib/:/usr/lib/]
  ignore line: [COLLECT_GCC_OPTIONS='-v' '-o' 'cmTryCompileExec1948335347' '-rdynamic' '-mtune=generic']
  link line: [ /usr/lib/gcc/x86_64-linux-gnu/4.4.3/collect2 --build-id --eh-frame-hdr -m elf_x86_64 --hash-style=both -export-dynamic -dynamic-linker /lib64/ld-linux-x86-64.so.2 -o cmTryCompileExec1948335347 -z relro /usr/lib/gcc/x86_64-linux-gnu/4.4.3/../../../../lib/crt1.o /usr/lib/gcc/x86_64-linux-gnu/4.4.3/../../../../lib/crti.o /usr/lib/gcc/x86_64-linux-gnu/4.4.3/crtbegin.o -L/usr/lib/gcc/x86_64-linux-gnu/4.4.3 -L/usr/lib/gcc/x86_64-linux-gnu/4.4.3 -L/usr/lib/gcc/x86_64-linux-gnu/4.4.3/../../../../lib -L/lib/../lib -L/usr/lib/../lib -L/usr/lib/gcc/x86_64-linux-gnu/4.4.3/../../.. CMakeFiles/cmTryCompileExec1948335347.dir/CMakeCCompilerABI.c.o -lgcc --as-needed -lgcc_s --no-as-needed -lc -lgcc --as-needed -lgcc_s --no-as-needed /usr/lib/gcc/x86_64-linux-gnu/4.4.3/crtend.o /usr/lib/gcc/x86_64-linux-gnu/4.4.3/../../../../lib/crtn.o]
    arg [/usr/lib/gcc/x86_64-linux-gnu/4.4.3/collect2] ==> ignore
    arg [--build-id] ==> ignore
    arg [--eh-frame-hdr] ==> ignore
    arg [-m] ==> ignore
    arg [elf_x86_64] ==> ignore
    arg [--hash-style=both] ==> ignore
    arg [-export-dynamic] ==> ignore
    arg [-dynamic-linker] ==> ignore
    arg [/lib64/ld-linux-x86-64.so.2] ==> ignore
    arg [-o] ==> ignore
    arg [cmTryCompileExec1948335347] ==> ignore
    arg [-zrelro] ==> ignore
    arg [/usr/lib/gcc/x86_64-linux-gnu/4.4.3/../../../../lib/crt1.o] ==> ignore
    arg [/usr/lib/gcc/x86_64-linux-gnu/4.4.3/../../../../lib/crti.o] ==> ignore
    arg [/usr/lib/gcc/x86_64-linux-gnu/4.4.3/crtbegin.o] ==> ignore
    arg [-L/usr/lib/gcc/x86_64-linux-gnu/4.4.3] ==> dir [/usr/lib/gcc/x86_64-linux-gnu/4.4.3]
    arg [-L/usr/lib/gcc/x86_64-linux-gnu/4.4.3] ==> dir [/usr/lib/gcc/x86_64-linux-gnu/4.4.3]
    arg [-L/usr/lib/gcc/x86_64-linux-gnu/4.4.3/../../../../lib] ==> dir [/usr/lib/gcc/x86_64-linux-gnu/4.4.3/../../../../lib]
    arg [-L/lib/../lib] ==> dir [/lib/../lib]
    arg [-L/usr/lib/../lib] ==> dir [/usr/lib/../lib]
    arg [-L/usr/lib/gcc/x86_64-linux-gnu/4.4.3/../../..] ==> dir [/usr/lib/gcc/x86_64-linux-gnu/4.4.3/../../..]
    arg [CMakeFiles/cmTryCompileExec1948335347.dir/CMakeCCompilerABI.c.o] ==> ignore
    arg [-lgcc] ==> lib [gcc]
    arg [--as-needed] ==> ignore
    arg [-lgcc_s] ==> lib [gcc_s]
    arg [--no-as-needed] ==> ignore
    arg [-lc] ==> lib [c]
    arg [-lgcc] ==> lib [gcc]
    arg [--as-needed] ==> ignore
    arg [-lgcc_s] ==> lib [gcc_s]
    arg [--no-as-needed] ==> ignore
    arg [/usr/lib/gcc/x86_64-linux-gnu/4.4.3/crtend.o] ==> ignore
    arg [/usr/lib/gcc/x86_64-linux-gnu/4.4.3/../../../../lib/crtn.o] ==> ignore
  remove lib [gcc]
  remove lib [gcc_s]
  remove lib [gcc]
  remove lib [gcc_s]
  collapse dir [/usr/lib/gcc/x86_64-linux-gnu/4.4.3] ==> [/usr/lib/gcc/x86_64-linux-gnu/4.4.3]
  collapse dir [/usr/lib/gcc/x86_64-linux-gnu/4.4.3] ==> [/usr/lib/gcc/x86_64-linux-gnu/4.4.3]
  collapse dir [/usr/lib/gcc/x86_64-linux-gnu/4.4.3/../../../../lib] ==> [/usr/lib]
  collapse dir [/lib/../lib] ==> [/lib]
  collapse dir [/usr/lib/../lib] ==> [/usr/lib]
  collapse dir [/usr/lib/gcc/x86_64-linux-gnu/4.4.3/../../..] ==> [/usr/lib]
  implicit libs: [c]
  implicit dirs: [/usr/lib/gcc/x86_64-linux-gnu/4.4.3;/usr/lib;/lib]


Determining if the CXX compiler works passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1146146823/fast"
make -f CMakeFiles/cmTryCompileExec1146146823.dir/build.make CMakeFiles/cmTryCompileExec1146146823.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec1146146823.dir/testCXXCompiler.cxx.o
/usr/bin/g++     -o CMakeFiles/cmTryCompileExec1146146823.dir/testCXXCompiler.cxx.o -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/testCXXCompiler.cxx
Linking CXX executable cmTryCompileExec1146146823
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1146146823.dir/link.txt --verbose=1
/usr/bin/g++          CMakeFiles/cmTryCompileExec1146146823.dir/testCXXCompiler.cxx.o  -o cmTryCompileExec1146146823 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Detecting CXX compiler ABI info compiled with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2607370771/fast"
make -f CMakeFiles/cmTryCompileExec2607370771.dir/build.make CMakeFiles/cmTryCompileExec2607370771.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec2607370771.dir/CMakeCXXCompilerABI.cpp.o
/usr/bin/g++     -o CMakeFiles/cmTryCompileExec2607370771.dir/CMakeCXXCompilerABI.cpp.o -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Modules/CMakeCXXCompilerABI.cpp
Linking CXX executable cmTryCompileExec2607370771
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2607370771.dir/link.txt --verbose=1
/usr/bin/g++        -v CMakeFiles/cmTryCompileExec2607370771.dir/CMakeCXXCompilerABI.cpp.o  -o cmTryCompileExec2607370771 -rdynamic  
Using built-in specs.
Target: x86_64-linux-gnu
Configured with: ../src/configure -v --with-pkgversion='Ubuntu 4.4.3-4ubuntu5' --with-bugurl=file:///usr/share/doc/gcc-4.4/README.Bugs --enable-languages=c,c++,fortran,objc,obj-c++ --prefix=/usr --enable-shared --enable-multiarch --enable-linker-build-id --with-system-zlib --libexecdir=/usr/lib --without-included-gettext --enable-threads=posix --with-gxx-include-dir=/usr/include/c++/4.4 --program-suffix=-4.4 --enable-nls --enable-clocale=gnu --enable-libstdcxx-debug --enable-plugin --enable-objc-gc --disable-werror --with-arch-32=i486 --with-tune=generic --enable-checking=release --build=x86_64-linux-gnu --host=x86_64-linux-gnu --target=x86_64-linux-gnu
Thread model: posix
gcc version 4.4.3 (Ubuntu 4.4.3-4ubuntu5) 
COMPILER_PATH=/usr/lib/gcc/x86_64-linux-gnu/4.4.3/:/usr/lib/gcc/x86_64-linux-gnu/4.4.3/:/usr/lib/gcc/x86_64-linux-gnu/:/usr/lib/gcc/x86_64-linux-gnu/4.4.3/:/usr/lib/gcc/x86_64-linux-gnu/:/usr/lib/gcc/x86_64-linux-gnu/4.4.3/:/usr/lib/gcc/x86_64-linux-gnu/
LIBRARY_PATH=/usr/lib/gcc/x86_64-linux-gnu/4.4.3/:/usr/lib/gcc/x86_64-linux-gnu/4.4.3/:/usr/lib/gcc/x86_64-linux-gnu/4.4.3/../../../../lib/:/lib/../lib/:/usr/lib/../lib/:/usr/lib/gcc/x86_64-linux-gnu/4.4.3/../../../:/lib/:/usr/lib/
COLLECT_GCC_OPTIONS='-v' '-o' 'cmTryCompileExec2607370771' '-rdynamic' '-shared-libgcc' '-mtune=generic'
 /usr/lib/gcc/x86_64-linux-gnu/4.4.3/collect2 --build-id --eh-frame-hdr -m elf_x86_64 --hash-style=both -export-dynamic -dynamic-linker /lib64/ld-linux-x86-64.so.2 -o cmTryCompileExec2607370771 -z relro /usr/lib/gcc/x86_64-linux-gnu/4.4.3/../../../../lib/crt1.o /usr/lib/gcc/x86_64-linux-gnu/4.4.3/../../../../lib/crti.o /usr/lib/gcc/x86_64-linux-gnu/4.4.3/crtbegin.o -L/usr/lib/gcc/x86_64-linux-gnu/4.4.3 -L/usr/lib/gcc/x86_64-linux-gnu/4.4.3 -L/usr/lib/gcc/x86_64-linux-gnu/4.4.3/../../../../lib -L/lib/../lib -L/usr/lib/../lib -L/usr/lib/gcc/x86_64-linux-gnu/4.4.3/../../.. CMakeFiles/cmTryCompileExec2607370771.dir/CMakeCXXCompilerABI.cpp.o -lstdc++ -lm -lgcc_s -lgcc -lc -lgcc_s -lgcc /usr/lib/gcc/x86_64-linux-gnu/4.4.3/crtend.o /usr/lib/gcc/x86_64-linux-gnu/4.4.3/../../../../lib/crtn.o
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Parsed CXX implicit link information from above output:
  link line regex: [^( *|.*[/\])(ld|ld|collect2)[^/\]*( |$)]
  ignore line: [Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp]
  ignore line: []
  ignore line: [Run Build Command:/usr/bin/make "cmTryCompileExec2607370771/fast"]
  ignore line: [make -f CMakeFiles/cmTryCompileExec2607370771.dir/build.make CMakeFiles/cmTryCompileExec2607370771.dir/build]
  ignore line: [make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp']
  ignore line: [/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1]
  ignore line: [Building CXX object CMakeFiles/cmTryCompileExec2607370771.dir/CMakeCXXCompilerABI.cpp.o]
  ignore line: [/usr/bin/g++     -o CMakeFiles/cmTryCompileExec2607370771.dir/CMakeCXXCompilerABI.cpp.o -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Modules/CMakeCXXCompilerABI.cpp]
  ignore line: [Linking CXX executable cmTryCompileExec2607370771]
  ignore line: [/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2607370771.dir/link.txt --verbose=1]
  ignore line: [/usr/bin/g++        -v CMakeFiles/cmTryCompileExec2607370771.dir/CMakeCXXCompilerABI.cpp.o  -o cmTryCompileExec2607370771 -rdynamic  ]
  ignore line: [Using built-in specs.]
  ignore line: [Target: x86_64-linux-gnu]
  ignore line: [Configured with: ../src/configure -v --with-pkgversion='Ubuntu 4.4.3-4ubuntu5' --with-bugurl=file:///usr/share/doc/gcc-4.4/README.Bugs --enable-languages=c,c++,fortran,objc,obj-c++ --prefix=/usr --enable-shared --enable-multiarch --enable-linker-build-id --with-system-zlib --libexecdir=/usr/lib --without-included-gettext --enable-threads=posix --with-gxx-include-dir=/usr/include/c++/4.4 --program-suffix=-4.4 --enable-nls --enable-clocale=gnu --enable-libstdcxx-debug --enable-plugin --enable-objc-gc --disable-werror --with-arch-32=i486 --with-tune=generic --enable-checking=release --build=x86_64-linux-gnu --host=x86_64-linux-gnu --target=x86_64-linux-gnu]
  ignore line: [Thread model: posix]
  ignore line: [gcc version 4.4.3 (Ubuntu 4.4.3-4ubuntu5) ]
  ignore line: [COMPILER_PATH=/usr/lib/gcc/x86_64-linux-gnu/4.4.3/:/usr/lib/gcc/x86_64-linux-gnu/4.4.3/:/usr/lib/gcc/x86_64-linux-gnu/:/usr/lib/gcc/x86_64-linux-gnu/4.4.3/:/usr/lib/gcc/x86_64-linux-gnu/:/usr/lib/gcc/x86_64-linux-gnu/4.4.3/:/usr/lib/gcc/x86_64-linux-gnu/]
  ignore line: [LIBRARY_PATH=/usr/lib/gcc/x86_64-linux-gnu/4.4.3/:/usr/lib/gcc/x86_64-linux-gnu/4.4.3/:/usr/lib/gcc/x86_64-linux-gnu/4.4.3/../../../../lib/:/lib/../lib/:/usr/lib/../lib/:/usr/lib/gcc/x86_64-linux-gnu/4.4.3/../../../:/lib/:/usr/lib/]
  ignore line: [COLLECT_GCC_OPTIONS='-v' '-o' 'cmTryCompileExec2607370771' '-rdynamic' '-shared-libgcc' '-mtune=generic']
  link line: [ /usr/lib/gcc/x86_64-linux-gnu/4.4.3/collect2 --build-id --eh-frame-hdr -m elf_x86_64 --hash-style=both -export-dynamic -dynamic-linker /lib64/ld-linux-x86-64.so.2 -o cmTryCompileExec2607370771 -z relro /usr/lib/gcc/x86_64-linux-gnu/4.4.3/../../../../lib/crt1.o /usr/lib/gcc/x86_64-linux-gnu/4.4.3/../../../../lib/crti.o /usr/lib/gcc/x86_64-linux-gnu/4.4.3/crtbegin.o -L/usr/lib/gcc/x86_64-linux-gnu/4.4.3 -L/usr/lib/gcc/x86_64-linux-gnu/4.4.3 -L/usr/lib/gcc/x86_64-linux-gnu/4.4.3/../../../../lib -L/lib/../lib -L/usr/lib/../lib -L/usr/lib/gcc/x86_64-linux-gnu/4.4.3/../../.. CMakeFiles/cmTryCompileExec2607370771.dir/CMakeCXXCompilerABI.cpp.o -lstdc++ -lm -lgcc_s -lgcc -lc -lgcc_s -lgcc /usr/lib/gcc/x86_64-linux-gnu/4.4.3/crtend.o /usr/lib/gcc/x86_64-linux-gnu/4.4.3/../../../../lib/crtn.o]
    arg [/usr/lib/gcc/x86_64-linux-gnu/4.4.3/collect2] ==> ignore
    arg [--build-id] ==> ignore
    arg [--eh-frame-hdr] ==> ignore
    arg [-m] ==> ignore
    arg [elf_x86_64] ==> ignore
    arg [--hash-style=both] ==> ignore
    arg [-export-dynamic] ==> ignore
    arg [-dynamic-linker] ==> ignore
    arg [/lib64/ld-linux-x86-64.so.2] ==> ignore
    arg [-o] ==> ignore
    arg [cmTryCompileExec2607370771] ==> ignore
    arg [-zrelro] ==> ignore
    arg [/usr/lib/gcc/x86_64-linux-gnu/4.4.3/../../../../lib/crt1.o] ==> ignore
    arg [/usr/lib/gcc/x86_64-linux-gnu/4.4.3/../../../../lib/crti.o] ==> ignore
    arg [/usr/lib/gcc/x86_64-linux-gnu/4.4.3/crtbegin.o] ==> ignore
    arg [-L/usr/lib/gcc/x86_64-linux-gnu/4.4.3] ==> dir [/usr/lib/gcc/x86_64-linux-gnu/4.4.3]
    arg [-L/usr/lib/gcc/x86_64-linux-gnu/4.4.3] ==> dir [/usr/lib/gcc/x86_64-linux-gnu/4.4.3]
    arg [-L/usr/lib/gcc/x86_64-linux-gnu/4.4.3/../../../../lib] ==> dir [/usr/lib/gcc/x86_64-linux-gnu/4.4.3/../../../../lib]
    arg [-L/lib/../lib] ==> dir [/lib/../lib]
    arg [-L/usr/lib/../lib] ==> dir [/usr/lib/../lib]
    arg [-L/usr/lib/gcc/x86_64-linux-gnu/4.4.3/../../..] ==> dir [/usr/lib/gcc/x86_64-linux-gnu/4.4.3/../../..]
    arg [CMakeFiles/cmTryCompileExec2607370771.dir/CMakeCXXCompilerABI.cpp.o] ==> ignore
    arg [-lstdc++] ==> lib [stdc++]
    arg [-lm] ==> lib [m]
    arg [-lgcc_s] ==> lib [gcc_s]
    arg [-lgcc] ==> lib [gcc]
    arg [-lc] ==> lib [c]
    arg [-lgcc_s] ==> lib [gcc_s]
    arg [-lgcc] ==> lib [gcc]
    arg [/usr/lib/gcc/x86_64-linux-gnu/4.4.3/crtend.o] ==> ignore
    arg [/usr/lib/gcc/x86_64-linux-gnu/4.4.3/../../../../lib/crtn.o] ==> ignore
  remove lib [gcc_s]
  remove lib [gcc]
  remove lib [gcc_s]
  remove lib [gcc]
  collapse dir [/usr/lib/gcc/x86_64-linux-gnu/4.4.3] ==> [/usr/lib/gcc/x86_64-linux-gnu/4.4.3]
  collapse dir [/usr/lib/gcc/x86_64-linux-gnu/4.4.3] ==> [/usr/lib/gcc/x86_64-linux-gnu/4.4.3]
  collapse dir [/usr/lib/gcc/x86_64-linux-gnu/4.4.3/../../../../lib] ==> [/usr/lib]
  collapse dir [/lib/../lib] ==> [/lib]
  collapse dir [/usr/lib/../lib] ==> [/usr/lib]
  collapse dir [/usr/lib/gcc/x86_64-linux-gnu/4.4.3/../../..] ==> [/usr/lib]
  implicit libs: [stdc++;m;c]
  implicit dirs: [/usr/lib/gcc/x86_64-linux-gnu/4.4.3;/usr/lib;/lib]


Determining if the include file iostream exists passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3360399981/fast"
make -f CMakeFiles/cmTryCompileExec3360399981.dir/build.make CMakeFiles/cmTryCompileExec3360399981.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec3360399981.dir/CheckIncludeFile.cxx.o
/usr/bin/g++     -o CMakeFiles/cmTryCompileExec3360399981.dir/CheckIncludeFile.cxx.o -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckIncludeFile.cxx
Linking CXX executable cmTryCompileExec3360399981
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3360399981.dir/link.txt --verbose=1
/usr/bin/g++           CMakeFiles/cmTryCompileExec3360399981.dir/CheckIncludeFile.cxx.o  -o cmTryCompileExec3360399981 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if the CXX compiler has std namespace passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2081625324/fast"
make -f CMakeFiles/cmTryCompileExec2081625324.dir/build.make CMakeFiles/cmTryCompileExec2081625324.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec2081625324.dir/TestForSTDNamespace.cxx.o
/usr/bin/g++     -o CMakeFiles/cmTryCompileExec2081625324.dir/TestForSTDNamespace.cxx.o -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Modules/TestForSTDNamespace.cxx
Linking CXX executable cmTryCompileExec2081625324
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2081625324.dir/link.txt --verbose=1
/usr/bin/g++           CMakeFiles/cmTryCompileExec2081625324.dir/TestForSTDNamespace.cxx.o  -o cmTryCompileExec2081625324 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if the CXX compiler understands ansi for scopes passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3389443614/fast"
make -f CMakeFiles/cmTryCompileExec3389443614.dir/build.make CMakeFiles/cmTryCompileExec3389443614.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec3389443614.dir/TestForAnsiForScope.cxx.o
/usr/bin/g++     -o CMakeFiles/cmTryCompileExec3389443614.dir/TestForAnsiForScope.cxx.o -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Modules/TestForAnsiForScope.cxx
Linking CXX executable cmTryCompileExec3389443614
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3389443614.dir/link.txt --verbose=1
/usr/bin/g++           CMakeFiles/cmTryCompileExec3389443614.dir/TestForAnsiForScope.cxx.o  -o cmTryCompileExec3389443614 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if the CXX compiler has sstream passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1850465697/fast"
make -f CMakeFiles/cmTryCompileExec1850465697.dir/build.make CMakeFiles/cmTryCompileExec1850465697.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec1850465697.dir/TestForSSTREAM.cxx.o
/usr/bin/g++     -o CMakeFiles/cmTryCompileExec1850465697.dir/TestForSSTREAM.cxx.o -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Modules/TestForSSTREAM.cxx
Linking CXX executable cmTryCompileExec1850465697
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1850465697.dir/link.txt --verbose=1
/usr/bin/g++           CMakeFiles/cmTryCompileExec1850465697.dir/TestForSSTREAM.cxx.o  -o cmTryCompileExec1850465697 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if the unsetenv exist passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec922548085/fast"
make -f CMakeFiles/cmTryCompileExec922548085.dir/build.make CMakeFiles/cmTryCompileExec922548085.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec922548085.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec922548085.dir/CheckSymbolExists.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec922548085
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec922548085.dir/link.txt --verbose=1
/usr/bin/gcc         CMakeFiles/cmTryCompileExec922548085.dir/CheckSymbolExists.c.o  -o cmTryCompileExec922548085 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'

File /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdlib.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef unsetenv
  return ((int*)(&unsetenv))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Checking whether header cstdio is available compiled with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec217739563/fast"
make -f CMakeFiles/cmTryCompileExec217739563.dir/build.make CMakeFiles/cmTryCompileExec217739563.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec217739563.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/g++   -DTEST_KWSYS_CXX_HAS_CSTDIO  -o CMakeFiles/cmTryCompileExec217739563.dir/kwsysPlatformTestsCXX.cxx.o -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec217739563
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec217739563.dir/link.txt --verbose=1
/usr/bin/g++          CMakeFiles/cmTryCompileExec217739563.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec217739563 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'


Checking for Large File Support compiled and ran with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3280946302/fast"
make -f CMakeFiles/cmTryCompileExec3280946302.dir/build.make CMakeFiles/cmTryCompileExec3280946302.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec3280946302.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/g++   -DTEST_KWSYS_LFS_WORKS -DKWSYS_CXX_HAS_CSTDIO=1  -o CMakeFiles/cmTryCompileExec3280946302.dir/kwsysPlatformTestsCXX.cxx.o -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec3280946302
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3280946302.dir/link.txt --verbose=1
/usr/bin/g++          CMakeFiles/cmTryCompileExec3280946302.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec3280946302 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'


Checking whether STL classes are in std namespace compiled with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1064595928/fast"
make -f CMakeFiles/cmTryCompileExec1064595928.dir/build.make CMakeFiles/cmTryCompileExec1064595928.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec1064595928.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/g++   -DTEST_KWSYS_STL_HAVE_STD  -o CMakeFiles/cmTryCompileExec1064595928.dir/kwsysPlatformTestsCXX.cxx.o -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec1064595928
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1064595928.dir/link.txt --verbose=1
/usr/bin/g++          CMakeFiles/cmTryCompileExec1064595928.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec1064595928 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'


Checking whether ANSI stream headers are available compiled with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3003433945/fast"
make -f CMakeFiles/cmTryCompileExec3003433945.dir/build.make CMakeFiles/cmTryCompileExec3003433945.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec3003433945.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/g++   -DTEST_KWSYS_IOS_USE_ANSI  -o CMakeFiles/cmTryCompileExec3003433945.dir/kwsysPlatformTestsCXX.cxx.o -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec3003433945
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3003433945.dir/link.txt --verbose=1
/usr/bin/g++          CMakeFiles/cmTryCompileExec3003433945.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec3003433945 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'


Checking whether ANSI streams are in std namespace compiled with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1948745526/fast"
make -f CMakeFiles/cmTryCompileExec1948745526.dir/build.make CMakeFiles/cmTryCompileExec1948745526.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec1948745526.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/g++   -DTEST_KWSYS_IOS_HAVE_STD  -o CMakeFiles/cmTryCompileExec1948745526.dir/kwsysPlatformTestsCXX.cxx.o -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec1948745526
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1948745526.dir/link.txt --verbose=1
/usr/bin/g++          CMakeFiles/cmTryCompileExec1948745526.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec1948745526 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'


Checking whether ANSI string stream is available compiled with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2404447016/fast"
make -f CMakeFiles/cmTryCompileExec2404447016.dir/build.make CMakeFiles/cmTryCompileExec2404447016.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec2404447016.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/g++   -DTEST_KWSYS_IOS_USE_SSTREAM  -o CMakeFiles/cmTryCompileExec2404447016.dir/kwsysPlatformTestsCXX.cxx.o -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec2404447016
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2404447016.dir/link.txt --verbose=1
/usr/bin/g++          CMakeFiles/cmTryCompileExec2404447016.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec2404447016 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'


Checking whether header cstddef is available compiled with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3058610947/fast"
make -f CMakeFiles/cmTryCompileExec3058610947.dir/build.make CMakeFiles/cmTryCompileExec3058610947.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec3058610947.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/g++   -DTEST_KWSYS_CXX_HAS_CSTDDEF  -o CMakeFiles/cmTryCompileExec3058610947.dir/kwsysPlatformTestsCXX.cxx.o -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec3058610947
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3058610947.dir/link.txt --verbose=1
/usr/bin/g++          CMakeFiles/cmTryCompileExec3058610947.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec3058610947 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'


Checking whether stl string has operator!= for char* compiled with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2989405906/fast"
make -f CMakeFiles/cmTryCompileExec2989405906.dir/build.make CMakeFiles/cmTryCompileExec2989405906.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec2989405906.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/g++   -DTEST_KWSYS_STL_STRING_HAVE_NEQ_CHAR -DKWSYS_STL_HAVE_STD=1  -o CMakeFiles/cmTryCompileExec2989405906.dir/kwsysPlatformTestsCXX.cxx.o -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec2989405906
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2989405906.dir/link.txt --verbose=1
/usr/bin/g++          CMakeFiles/cmTryCompileExec2989405906.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec2989405906 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'


Checking whether stl has iterator_traits compiled with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2172960780/fast"
make -f CMakeFiles/cmTryCompileExec2172960780.dir/build.make CMakeFiles/cmTryCompileExec2172960780.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec2172960780.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/g++   -DTEST_KWSYS_STL_HAS_ITERATOR_TRAITS -DKWSYS_STL_HAVE_STD=1  -o CMakeFiles/cmTryCompileExec2172960780.dir/kwsysPlatformTestsCXX.cxx.o -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec2172960780
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2172960780.dir/link.txt --verbose=1
/usr/bin/g++          CMakeFiles/cmTryCompileExec2172960780.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec2172960780 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'


Checking whether stl has standard template allocator compiled with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec633611247/fast"
make -f CMakeFiles/cmTryCompileExec633611247.dir/build.make CMakeFiles/cmTryCompileExec633611247.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec633611247.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/g++   -DTEST_KWSYS_STL_HAS_ALLOCATOR_TEMPLATE -DKWSYS_STL_HAVE_STD=1  -o CMakeFiles/cmTryCompileExec633611247.dir/kwsysPlatformTestsCXX.cxx.o -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec633611247
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec633611247.dir/link.txt --verbose=1
/usr/bin/g++          CMakeFiles/cmTryCompileExec633611247.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec633611247 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'


Checking for rebind member of stl allocator compiled with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1955754099/fast"
make -f CMakeFiles/cmTryCompileExec1955754099.dir/build.make CMakeFiles/cmTryCompileExec1955754099.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec1955754099.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/g++   -DTEST_KWSYS_STL_HAS_ALLOCATOR_REBIND -DKWSYS_STL_HAVE_STD=1  -o CMakeFiles/cmTryCompileExec1955754099.dir/kwsysPlatformTestsCXX.cxx.o -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec1955754099
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1955754099.dir/link.txt --verbose=1
/usr/bin/g++          CMakeFiles/cmTryCompileExec1955754099.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec1955754099 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'


Checking whether stl containers support allocator objects. compiled with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3889843879/fast"
make -f CMakeFiles/cmTryCompileExec3889843879.dir/build.make CMakeFiles/cmTryCompileExec3889843879.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec3889843879.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/g++   -DTEST_KWSYS_STL_HAS_ALLOCATOR_OBJECTS -DKWSYS_STL_HAVE_STD=1  -o CMakeFiles/cmTryCompileExec3889843879.dir/kwsysPlatformTestsCXX.cxx.o -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec3889843879
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3889843879.dir/link.txt --verbose=1
/usr/bin/g++          CMakeFiles/cmTryCompileExec3889843879.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec3889843879 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'


Checking whether ios has binary openmode compiled with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3139681905/fast"
make -f CMakeFiles/cmTryCompileExec3139681905.dir/build.make CMakeFiles/cmTryCompileExec3139681905.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec3139681905.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/g++   -DTEST_KWSYS_IOS_HAVE_BINARY -DKWSYS_IOS_USE_ANSI=1 -DKWSYS_IOS_HAVE_STD=1  -o CMakeFiles/cmTryCompileExec3139681905.dir/kwsysPlatformTestsCXX.cxx.o -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec3139681905
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3139681905.dir/link.txt --verbose=1
/usr/bin/g++          CMakeFiles/cmTryCompileExec3139681905.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec3139681905 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'


Checking for member template support compiled with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3504789417/fast"
make -f CMakeFiles/cmTryCompileExec3504789417.dir/build.make CMakeFiles/cmTryCompileExec3504789417.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec3504789417.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/g++   -DTEST_KWSYS_CXX_HAS_MEMBER_TEMPLATES  -o CMakeFiles/cmTryCompileExec3504789417.dir/kwsysPlatformTestsCXX.cxx.o -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec3504789417
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3504789417.dir/link.txt --verbose=1
/usr/bin/g++          CMakeFiles/cmTryCompileExec3504789417.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec3504789417 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'


Checking for standard template specialization syntax compiled with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3534059189/fast"
make -f CMakeFiles/cmTryCompileExec3534059189.dir/build.make CMakeFiles/cmTryCompileExec3534059189.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec3534059189.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/g++   -DTEST_KWSYS_CXX_HAS_FULL_SPECIALIZATION  -o CMakeFiles/cmTryCompileExec3534059189.dir/kwsysPlatformTestsCXX.cxx.o -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec3534059189
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3534059189.dir/link.txt --verbose=1
/usr/bin/g++          CMakeFiles/cmTryCompileExec3534059189.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec3534059189 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'


Checking whether argument dependent lookup is supported compiled with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2889577348/fast"
make -f CMakeFiles/cmTryCompileExec2889577348.dir/build.make CMakeFiles/cmTryCompileExec2889577348.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec2889577348.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/g++   -DTEST_KWSYS_CXX_HAS_ARGUMENT_DEPENDENT_LOOKUP  -o CMakeFiles/cmTryCompileExec2889577348.dir/kwsysPlatformTestsCXX.cxx.o -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec2889577348
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2889577348.dir/link.txt --verbose=1
/usr/bin/g++          CMakeFiles/cmTryCompileExec2889577348.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec2889577348 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'


Checking whether struct stat has st_mtim member compiled with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec4251039043/fast"
make -f CMakeFiles/cmTryCompileExec4251039043.dir/build.make CMakeFiles/cmTryCompileExec4251039043.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec4251039043.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/g++   -DTEST_KWSYS_STAT_HAS_ST_MTIM  -o CMakeFiles/cmTryCompileExec4251039043.dir/kwsysPlatformTestsCXX.cxx.o -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec4251039043
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec4251039043.dir/link.txt --verbose=1
/usr/bin/g++          CMakeFiles/cmTryCompileExec4251039043.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec4251039043 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'


Checking whether C++ compiler has 'long long' compiled with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2084733101/fast"
make -f CMakeFiles/cmTryCompileExec2084733101.dir/build.make CMakeFiles/cmTryCompileExec2084733101.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec2084733101.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/g++   -DTEST_KWSYS_CXX_HAS_LONG_LONG  -o CMakeFiles/cmTryCompileExec2084733101.dir/kwsysPlatformTestsCXX.cxx.o -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec2084733101
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2084733101.dir/link.txt --verbose=1
/usr/bin/g++          CMakeFiles/cmTryCompileExec2084733101.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec2084733101 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'


Checking for C type size macros compiled with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1286792560/fast"
make -f CMakeFiles/cmTryCompileExec1286792560.dir/build.make CMakeFiles/cmTryCompileExec1286792560.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1286792560.dir/kwsysPlatformTestsC.c.o
/usr/bin/gcc  -DTEST_KWSYS_C_TYPE_MACROS  -o CMakeFiles/cmTryCompileExec1286792560.dir/kwsysPlatformTestsC.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Source/kwsys/kwsysPlatformTestsC.c
Linking C executable cmTryCompileExec1286792560
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1286792560.dir/link.txt --verbose=1
/usr/bin/gcc         CMakeFiles/cmTryCompileExec1286792560.dir/kwsysPlatformTestsC.c.o  -o cmTryCompileExec1286792560 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'


Determining if the include file sys/types.h exists passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec693418368/fast"
make -f CMakeFiles/cmTryCompileExec693418368.dir/build.make CMakeFiles/cmTryCompileExec693418368.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec693418368.dir/CheckIncludeFile.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec693418368.dir/CheckIncludeFile.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckIncludeFile.c
Linking C executable cmTryCompileExec693418368
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec693418368.dir/link.txt --verbose=1
/usr/bin/gcc         CMakeFiles/cmTryCompileExec693418368.dir/CheckIncludeFile.c.o  -o cmTryCompileExec693418368 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if the include file stdint.h exists passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3116495785/fast"
make -f CMakeFiles/cmTryCompileExec3116495785.dir/build.make CMakeFiles/cmTryCompileExec3116495785.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3116495785.dir/CheckIncludeFile.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec3116495785.dir/CheckIncludeFile.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckIncludeFile.c
Linking C executable cmTryCompileExec3116495785
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3116495785.dir/link.txt --verbose=1
/usr/bin/gcc         CMakeFiles/cmTryCompileExec3116495785.dir/CheckIncludeFile.c.o  -o cmTryCompileExec3116495785 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if the include file stddef.h exists passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3925409696/fast"
make -f CMakeFiles/cmTryCompileExec3925409696.dir/build.make CMakeFiles/cmTryCompileExec3925409696.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3925409696.dir/CheckIncludeFile.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec3925409696.dir/CheckIncludeFile.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckIncludeFile.c
Linking C executable cmTryCompileExec3925409696
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3925409696.dir/link.txt --verbose=1
/usr/bin/gcc         CMakeFiles/cmTryCompileExec3925409696.dir/CheckIncludeFile.c.o  -o cmTryCompileExec3925409696 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining size of char passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec640026078/fast"
make -f CMakeFiles/cmTryCompileExec640026078.dir/build.make CMakeFiles/cmTryCompileExec640026078.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec640026078.dir/KWSYS_SIZEOF_CHAR.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec640026078.dir/KWSYS_SIZEOF_CHAR.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CheckTypeSize/KWSYS_SIZEOF_CHAR.c
Linking C executable cmTryCompileExec640026078
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec640026078.dir/link.txt --verbose=1
/usr/bin/gcc         CMakeFiles/cmTryCompileExec640026078.dir/KWSYS_SIZEOF_CHAR.c.o  -o cmTryCompileExec640026078 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Checking whether char is signed compiled and ran with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3793103702/fast"
make -f CMakeFiles/cmTryCompileExec3793103702.dir/build.make CMakeFiles/cmTryCompileExec3793103702.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec3793103702.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/g++   -DTEST_KWSYS_CHAR_IS_SIGNED  -o CMakeFiles/cmTryCompileExec3793103702.dir/kwsysPlatformTestsCXX.cxx.o -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec3793103702
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3793103702.dir/link.txt --verbose=1
/usr/bin/g++          CMakeFiles/cmTryCompileExec3793103702.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec3793103702 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'


Checking if istream supports long long compiled with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1676405567/fast"
make -f CMakeFiles/cmTryCompileExec1676405567.dir/build.make CMakeFiles/cmTryCompileExec1676405567.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec1676405567.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/g++   -DTEST_KWSYS_IOS_HAS_ISTREAM_LONG_LONG -DKWSYS_IOS_USE_ANSI=1 -DKWSYS_IOS_HAVE_STD=1  -o CMakeFiles/cmTryCompileExec1676405567.dir/kwsysPlatformTestsCXX.cxx.o -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec1676405567
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1676405567.dir/link.txt --verbose=1
/usr/bin/g++          CMakeFiles/cmTryCompileExec1676405567.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec1676405567 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'


Checking if ostream supports long long compiled with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2965593053/fast"
make -f CMakeFiles/cmTryCompileExec2965593053.dir/build.make CMakeFiles/cmTryCompileExec2965593053.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec2965593053.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/g++   -DTEST_KWSYS_IOS_HAS_OSTREAM_LONG_LONG -DKWSYS_IOS_USE_ANSI=1 -DKWSYS_IOS_HAVE_STD=1  -o CMakeFiles/cmTryCompileExec2965593053.dir/kwsysPlatformTestsCXX.cxx.o -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec2965593053
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2965593053.dir/link.txt --verbose=1
/usr/bin/g++          CMakeFiles/cmTryCompileExec2965593053.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec2965593053 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'


Checking whether C compiler has ptrdiff_t in stddef.h compiled with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3366880011/fast"
make -f CMakeFiles/cmTryCompileExec3366880011.dir/build.make CMakeFiles/cmTryCompileExec3366880011.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3366880011.dir/kwsysPlatformTestsC.c.o
/usr/bin/gcc  -DTEST_KWSYS_C_HAS_PTRDIFF_T  -o CMakeFiles/cmTryCompileExec3366880011.dir/kwsysPlatformTestsC.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Source/kwsys/kwsysPlatformTestsC.c
Linking C executable cmTryCompileExec3366880011
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3366880011.dir/link.txt --verbose=1
/usr/bin/gcc         CMakeFiles/cmTryCompileExec3366880011.dir/kwsysPlatformTestsC.c.o  -o cmTryCompileExec3366880011 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'


Checking whether C compiler has ssize_t in unistd.h compiled with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3103924139/fast"
make -f CMakeFiles/cmTryCompileExec3103924139.dir/build.make CMakeFiles/cmTryCompileExec3103924139.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3103924139.dir/kwsysPlatformTestsC.c.o
/usr/bin/gcc  -DTEST_KWSYS_C_HAS_SSIZE_T  -o CMakeFiles/cmTryCompileExec3103924139.dir/kwsysPlatformTestsC.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Source/kwsys/kwsysPlatformTestsC.c
Linking C executable cmTryCompileExec3103924139
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3103924139.dir/link.txt --verbose=1
/usr/bin/gcc         CMakeFiles/cmTryCompileExec3103924139.dir/kwsysPlatformTestsC.c.o  -o cmTryCompileExec3103924139 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'


Checking whether CXX compiler has setenv compiled with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2670301293/fast"
make -f CMakeFiles/cmTryCompileExec2670301293.dir/build.make CMakeFiles/cmTryCompileExec2670301293.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec2670301293.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/g++   -DTEST_KWSYS_CXX_HAS_SETENV  -o CMakeFiles/cmTryCompileExec2670301293.dir/kwsysPlatformTestsCXX.cxx.o -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec2670301293
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2670301293.dir/link.txt --verbose=1
/usr/bin/g++          CMakeFiles/cmTryCompileExec2670301293.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec2670301293 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'


Checking whether CXX compiler has unsetenv compiled with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec668558238/fast"
make -f CMakeFiles/cmTryCompileExec668558238.dir/build.make CMakeFiles/cmTryCompileExec668558238.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec668558238.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/g++   -DTEST_KWSYS_CXX_HAS_UNSETENV  -o CMakeFiles/cmTryCompileExec668558238.dir/kwsysPlatformTestsCXX.cxx.o -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec668558238
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec668558238.dir/link.txt --verbose=1
/usr/bin/g++          CMakeFiles/cmTryCompileExec668558238.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec668558238 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'


Determining if the function gethostbyname exists in the c passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2883282045/fast"
make -f CMakeFiles/cmTryCompileExec2883282045.dir/build.make CMakeFiles/cmTryCompileExec2883282045.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2883282045.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -DCHECK_FUNCTION_EXISTS=gethostbyname   -o CMakeFiles/cmTryCompileExec2883282045.dir/CheckFunctionExists.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec2883282045
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2883282045.dir/link.txt --verbose=1
/usr/bin/gcc      -DCHECK_FUNCTION_EXISTS=gethostbyname    CMakeFiles/cmTryCompileExec2883282045.dir/CheckFunctionExists.c.o  -o cmTryCompileExec2883282045 -rdynamic -lc 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if the function idna_to_ascii_lz exists in the idn;dl passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3375071624/fast"
make -f CMakeFiles/cmTryCompileExec3375071624.dir/build.make CMakeFiles/cmTryCompileExec3375071624.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3375071624.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -DCHECK_FUNCTION_EXISTS=idna_to_ascii_lz   -o CMakeFiles/cmTryCompileExec3375071624.dir/CheckFunctionExists.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec3375071624
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3375071624.dir/link.txt --verbose=1
/usr/bin/gcc      -DCHECK_FUNCTION_EXISTS=idna_to_ascii_lz    CMakeFiles/cmTryCompileExec3375071624.dir/CheckFunctionExists.c.o  -o cmTryCompileExec3375071624 -rdynamic -lidn -ldl 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if the function dlopen exists in the dl;idn passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1215484446/fast"
make -f CMakeFiles/cmTryCompileExec1215484446.dir/build.make CMakeFiles/cmTryCompileExec1215484446.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1215484446.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -DCHECK_FUNCTION_EXISTS=dlopen   -o CMakeFiles/cmTryCompileExec1215484446.dir/CheckFunctionExists.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec1215484446
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1215484446.dir/link.txt --verbose=1
/usr/bin/gcc      -DCHECK_FUNCTION_EXISTS=dlopen    CMakeFiles/cmTryCompileExec1215484446.dir/CheckFunctionExists.c.o  -o cmTryCompileExec1215484446 -rdynamic -ldl -lidn 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if the include file features.h exists passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec947103751/fast"
make -f CMakeFiles/cmTryCompileExec947103751.dir/build.make CMakeFiles/cmTryCompileExec947103751.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec947103751.dir/CheckIncludeFile.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec947103751.dir/CheckIncludeFile.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckIncludeFile.c
Linking C executable cmTryCompileExec947103751
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec947103751.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec947103751.dir/CheckIncludeFile.c.o  -o cmTryCompileExec947103751 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if files ;stdio.h exist passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3187818157/fast"
make -f CMakeFiles/cmTryCompileExec3187818157.dir/build.make CMakeFiles/cmTryCompileExec3187818157.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3187818157.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec3187818157.dir/CheckIncludeFiles.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec3187818157
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3187818157.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec3187818157.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec3187818157 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h exist passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec4091257369/fast"
make -f CMakeFiles/cmTryCompileExec4091257369.dir/build.make CMakeFiles/cmTryCompileExec4091257369.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec4091257369.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec4091257369.dir/CheckIncludeFiles.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec4091257369
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec4091257369.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec4091257369.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec4091257369 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h exist passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec703769018/fast"
make -f CMakeFiles/cmTryCompileExec703769018.dir/build.make CMakeFiles/cmTryCompileExec703769018.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec703769018.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec703769018.dir/CheckIncludeFiles.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec703769018
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec703769018.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec703769018.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec703769018 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h exist passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2094207248/fast"
make -f CMakeFiles/cmTryCompileExec2094207248.dir/build.make CMakeFiles/cmTryCompileExec2094207248.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2094207248.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec2094207248.dir/CheckIncludeFiles.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec2094207248
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2094207248.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec2094207248.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec2094207248 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h exist passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1630137360/fast"
make -f CMakeFiles/cmTryCompileExec1630137360.dir/build.make CMakeFiles/cmTryCompileExec1630137360.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1630137360.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec1630137360.dir/CheckIncludeFiles.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec1630137360
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1630137360.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec1630137360.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec1630137360 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h exist passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3227409825/fast"
make -f CMakeFiles/cmTryCompileExec3227409825.dir/build.make CMakeFiles/cmTryCompileExec3227409825.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3227409825.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec3227409825.dir/CheckIncludeFiles.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec3227409825
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3227409825.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec3227409825.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec3227409825 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h exist passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1367971746/fast"
make -f CMakeFiles/cmTryCompileExec1367971746.dir/build.make CMakeFiles/cmTryCompileExec1367971746.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1367971746.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec1367971746.dir/CheckIncludeFiles.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec1367971746
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1367971746.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec1367971746.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec1367971746 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h exist passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1307167969/fast"
make -f CMakeFiles/cmTryCompileExec1307167969.dir/build.make CMakeFiles/cmTryCompileExec1307167969.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1307167969.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec1307167969.dir/CheckIncludeFiles.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec1307167969
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1307167969.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec1307167969.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec1307167969 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h exist passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec147931961/fast"
make -f CMakeFiles/cmTryCompileExec147931961.dir/build.make CMakeFiles/cmTryCompileExec147931961.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec147931961.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec147931961.dir/CheckIncludeFiles.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec147931961
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec147931961.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec147931961.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec147931961 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h exist passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1887447707/fast"
make -f CMakeFiles/cmTryCompileExec1887447707.dir/build.make CMakeFiles/cmTryCompileExec1887447707.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1887447707.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec1887447707.dir/CheckIncludeFiles.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec1887447707
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1887447707.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec1887447707.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec1887447707 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h exist passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3243433091/fast"
make -f CMakeFiles/cmTryCompileExec3243433091.dir/build.make CMakeFiles/cmTryCompileExec3243433091.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3243433091.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec3243433091.dir/CheckIncludeFiles.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec3243433091
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3243433091.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec3243433091.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec3243433091 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h exist passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3443179828/fast"
make -f CMakeFiles/cmTryCompileExec3443179828.dir/build.make CMakeFiles/cmTryCompileExec3443179828.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3443179828.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec3443179828.dir/CheckIncludeFiles.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec3443179828
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3443179828.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec3443179828.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec3443179828 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h exist passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3802084363/fast"
make -f CMakeFiles/cmTryCompileExec3802084363.dir/build.make CMakeFiles/cmTryCompileExec3802084363.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3802084363.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec3802084363.dir/CheckIncludeFiles.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec3802084363
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3802084363.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec3802084363.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec3802084363 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h exist passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3129840323/fast"
make -f CMakeFiles/cmTryCompileExec3129840323.dir/build.make CMakeFiles/cmTryCompileExec3129840323.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3129840323.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec3129840323.dir/CheckIncludeFiles.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec3129840323
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3129840323.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec3129840323.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec3129840323 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h exist passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1367508562/fast"
make -f CMakeFiles/cmTryCompileExec1367508562.dir/build.make CMakeFiles/cmTryCompileExec1367508562.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1367508562.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec1367508562.dir/CheckIncludeFiles.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec1367508562
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1367508562.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec1367508562.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec1367508562 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h exist passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec205482428/fast"
make -f CMakeFiles/cmTryCompileExec205482428.dir/build.make CMakeFiles/cmTryCompileExec205482428.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec205482428.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec205482428.dir/CheckIncludeFiles.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec205482428
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec205482428.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec205482428.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec205482428 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h exist passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1174565141/fast"
make -f CMakeFiles/cmTryCompileExec1174565141.dir/build.make CMakeFiles/cmTryCompileExec1174565141.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1174565141.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec1174565141.dir/CheckIncludeFiles.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec1174565141
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1174565141.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec1174565141.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec1174565141 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h exist passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3090822767/fast"
make -f CMakeFiles/cmTryCompileExec3090822767.dir/build.make CMakeFiles/cmTryCompileExec3090822767.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3090822767.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec3090822767.dir/CheckIncludeFiles.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec3090822767
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3090822767.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec3090822767.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec3090822767 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h exist passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3076566491/fast"
make -f CMakeFiles/cmTryCompileExec3076566491.dir/build.make CMakeFiles/cmTryCompileExec3076566491.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3076566491.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec3076566491.dir/CheckIncludeFiles.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec3076566491
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3076566491.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec3076566491.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec3076566491 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h exist passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec55361448/fast"
make -f CMakeFiles/cmTryCompileExec55361448.dir/build.make CMakeFiles/cmTryCompileExec55361448.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec55361448.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec55361448.dir/CheckIncludeFiles.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec55361448
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec55361448.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec55361448.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec55361448 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h exist passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec546169254/fast"
make -f CMakeFiles/cmTryCompileExec546169254.dir/build.make CMakeFiles/cmTryCompileExec546169254.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec546169254.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec546169254.dir/CheckIncludeFiles.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec546169254
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec546169254.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec546169254.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec546169254 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h;stdint.h;stdlib.h exist passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2600402746/fast"
make -f CMakeFiles/cmTryCompileExec2600402746.dir/build.make CMakeFiles/cmTryCompileExec2600402746.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2600402746.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec2600402746.dir/CheckIncludeFiles.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec2600402746
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2600402746.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec2600402746.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec2600402746 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h;stdint.h;stdlib.h;string.h exist passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1428939112/fast"
make -f CMakeFiles/cmTryCompileExec1428939112.dir/build.make CMakeFiles/cmTryCompileExec1428939112.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1428939112.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec1428939112.dir/CheckIncludeFiles.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec1428939112
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1428939112.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec1428939112.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec1428939112 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h;stdint.h;stdlib.h;string.h;strings.h exist passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2473090463/fast"
make -f CMakeFiles/cmTryCompileExec2473090463.dir/build.make CMakeFiles/cmTryCompileExec2473090463.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2473090463.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec2473090463.dir/CheckIncludeFiles.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec2473090463
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2473090463.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec2473090463.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec2473090463 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h;stdint.h;stdlib.h;string.h;strings.h;sys/param.h exist passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec751244478/fast"
make -f CMakeFiles/cmTryCompileExec751244478.dir/build.make CMakeFiles/cmTryCompileExec751244478.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec751244478.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec751244478.dir/CheckIncludeFiles.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec751244478
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec751244478.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec751244478.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec751244478 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h;stdint.h;stdlib.h;string.h;strings.h;sys/param.h;sys/stat.h exist passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1011027973/fast"
make -f CMakeFiles/cmTryCompileExec1011027973.dir/build.make CMakeFiles/cmTryCompileExec1011027973.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1011027973.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec1011027973.dir/CheckIncludeFiles.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec1011027973
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1011027973.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec1011027973.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec1011027973 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h;stdint.h;stdlib.h;string.h;strings.h;sys/param.h;sys/stat.h;sys/time.h exist passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1226630739/fast"
make -f CMakeFiles/cmTryCompileExec1226630739.dir/build.make CMakeFiles/cmTryCompileExec1226630739.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1226630739.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec1226630739.dir/CheckIncludeFiles.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec1226630739
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1226630739.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec1226630739.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec1226630739 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h;stdint.h;stdlib.h;string.h;strings.h;sys/param.h;sys/stat.h;sys/time.h;sys/resource.h exist passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3942084897/fast"
make -f CMakeFiles/cmTryCompileExec3942084897.dir/build.make CMakeFiles/cmTryCompileExec3942084897.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3942084897.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec3942084897.dir/CheckIncludeFiles.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec3942084897
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3942084897.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec3942084897.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec3942084897 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h;stdint.h;stdlib.h;string.h;strings.h;sys/param.h;sys/stat.h;sys/time.h;sys/resource.h;termios.h exist passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3029634000/fast"
make -f CMakeFiles/cmTryCompileExec3029634000.dir/build.make CMakeFiles/cmTryCompileExec3029634000.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3029634000.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec3029634000.dir/CheckIncludeFiles.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec3029634000
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3029634000.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec3029634000.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec3029634000 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h;stdint.h;stdlib.h;string.h;strings.h;sys/param.h;sys/stat.h;sys/time.h;sys/resource.h;termios.h;termio.h exist passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2887059474/fast"
make -f CMakeFiles/cmTryCompileExec2887059474.dir/build.make CMakeFiles/cmTryCompileExec2887059474.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2887059474.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec2887059474.dir/CheckIncludeFiles.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec2887059474
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2887059474.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec2887059474.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec2887059474 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h;stdint.h;stdlib.h;string.h;strings.h;sys/param.h;sys/stat.h;sys/time.h;sys/resource.h;termios.h;termio.h;time.h exist passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec369073159/fast"
make -f CMakeFiles/cmTryCompileExec369073159.dir/build.make CMakeFiles/cmTryCompileExec369073159.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec369073159.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec369073159.dir/CheckIncludeFiles.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec369073159
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec369073159.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec369073159.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec369073159 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h;stdint.h;stdlib.h;string.h;strings.h;sys/param.h;sys/stat.h;sys/time.h;sys/resource.h;termios.h;termio.h;time.h;unistd.h exist passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2550517675/fast"
make -f CMakeFiles/cmTryCompileExec2550517675.dir/build.make CMakeFiles/cmTryCompileExec2550517675.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2550517675.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec2550517675.dir/CheckIncludeFiles.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec2550517675
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2550517675.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec2550517675.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec2550517675 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h;stdint.h;stdlib.h;string.h;strings.h;sys/param.h;sys/stat.h;sys/time.h;sys/resource.h;termios.h;termio.h;time.h;unistd.h;locale.h exist passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3936789877/fast"
make -f CMakeFiles/cmTryCompileExec3936789877.dir/build.make CMakeFiles/cmTryCompileExec3936789877.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3936789877.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec3936789877.dir/CheckIncludeFiles.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec3936789877
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3936789877.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec3936789877.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec3936789877 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h;stdint.h;stdlib.h;string.h;strings.h;sys/param.h;sys/stat.h;sys/time.h;sys/resource.h;termios.h;termio.h;time.h;unistd.h;locale.h;setjmp.h exist passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1728027279/fast"
make -f CMakeFiles/cmTryCompileExec1728027279.dir/build.make CMakeFiles/cmTryCompileExec1728027279.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1728027279.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec1728027279.dir/CheckIncludeFiles.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec1728027279
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1728027279.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec1728027279.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec1728027279 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h;stdint.h;stdlib.h;string.h;strings.h;sys/param.h;sys/stat.h;sys/time.h;sys/resource.h;termios.h;termio.h;time.h;unistd.h;locale.h;setjmp.h;signal.h exist passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec341786419/fast"
make -f CMakeFiles/cmTryCompileExec341786419.dir/build.make CMakeFiles/cmTryCompileExec341786419.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec341786419.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec341786419.dir/CheckIncludeFiles.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec341786419
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec341786419.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec341786419.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec341786419 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h;stdint.h;stdlib.h;string.h;strings.h;sys/param.h;sys/stat.h;sys/time.h;sys/resource.h;termios.h;termio.h;time.h;unistd.h;locale.h;setjmp.h;signal.h;sys/ioctl.h exist passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3495744986/fast"
make -f CMakeFiles/cmTryCompileExec3495744986.dir/build.make CMakeFiles/cmTryCompileExec3495744986.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3495744986.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec3495744986.dir/CheckIncludeFiles.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec3495744986
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3495744986.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec3495744986.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec3495744986 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h;stdint.h;stdlib.h;string.h;strings.h;sys/param.h;sys/stat.h;sys/time.h;sys/resource.h;termios.h;termio.h;time.h;unistd.h;locale.h;setjmp.h;signal.h;sys/ioctl.h;sys/utsname.h exist passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2912994836/fast"
make -f CMakeFiles/cmTryCompileExec2912994836.dir/build.make CMakeFiles/cmTryCompileExec2912994836.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2912994836.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec2912994836.dir/CheckIncludeFiles.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec2912994836
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2912994836.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec2912994836.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec2912994836 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h;stdint.h;stdlib.h;string.h;strings.h;sys/param.h;sys/stat.h;sys/time.h;sys/resource.h;termios.h;termio.h;time.h;unistd.h;locale.h;setjmp.h;signal.h;sys/ioctl.h;sys/utsname.h;idn-free.h exist passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2042861235/fast"
make -f CMakeFiles/cmTryCompileExec2042861235.dir/build.make CMakeFiles/cmTryCompileExec2042861235.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2042861235.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec2042861235.dir/CheckIncludeFiles.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec2042861235
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2042861235.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec2042861235.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec2042861235 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h;stdint.h;stdlib.h;string.h;strings.h;sys/param.h;sys/stat.h;sys/time.h;sys/resource.h;termios.h;termio.h;time.h;unistd.h;locale.h;setjmp.h;signal.h;sys/ioctl.h;sys/utsname.h;idn-free.h;idna.h exist passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1493862574/fast"
make -f CMakeFiles/cmTryCompileExec1493862574.dir/build.make CMakeFiles/cmTryCompileExec1493862574.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1493862574.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec1493862574.dir/CheckIncludeFiles.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec1493862574
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1493862574.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec1493862574.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec1493862574 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h;stdint.h;stdlib.h;string.h;strings.h;sys/param.h;sys/stat.h;sys/time.h;sys/resource.h;termios.h;termio.h;time.h;unistd.h;locale.h;setjmp.h;signal.h;sys/ioctl.h;sys/utsname.h;idn-free.h;idna.h;tld.h exist passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3428414676/fast"
make -f CMakeFiles/cmTryCompileExec3428414676.dir/build.make CMakeFiles/cmTryCompileExec3428414676.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3428414676.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec3428414676.dir/CheckIncludeFiles.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec3428414676
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3428414676.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec3428414676.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec3428414676 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h;stdint.h;stdlib.h;string.h;strings.h;sys/param.h;sys/stat.h;sys/time.h;sys/resource.h;termios.h;termio.h;time.h;unistd.h;locale.h;setjmp.h;signal.h;sys/ioctl.h;sys/utsname.h;idn-free.h;idna.h;tld.h;arpa/tftp.h exist passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3605286234/fast"
make -f CMakeFiles/cmTryCompileExec3605286234.dir/build.make CMakeFiles/cmTryCompileExec3605286234.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3605286234.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec3605286234.dir/CheckIncludeFiles.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec3605286234
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3605286234.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec3605286234.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec3605286234 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h;stdint.h;stdlib.h;string.h;strings.h;sys/param.h;sys/stat.h;sys/time.h;sys/resource.h;termios.h;termio.h;time.h;unistd.h;locale.h;setjmp.h;signal.h;sys/ioctl.h;sys/utsname.h;idn-free.h;idna.h;tld.h;arpa/tftp.h;errno.h exist passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3708027487/fast"
make -f CMakeFiles/cmTryCompileExec3708027487.dir/build.make CMakeFiles/cmTryCompileExec3708027487.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3708027487.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec3708027487.dir/CheckIncludeFiles.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec3708027487
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3708027487.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec3708027487.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec3708027487 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h;stdint.h;stdlib.h;string.h;strings.h;sys/param.h;sys/stat.h;sys/time.h;sys/resource.h;termios.h;termio.h;time.h;unistd.h;locale.h;setjmp.h;signal.h;sys/ioctl.h;sys/utsname.h;idn-free.h;idna.h;tld.h;arpa/tftp.h;errno.h;libgen.h exist passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2077471562/fast"
make -f CMakeFiles/cmTryCompileExec2077471562.dir/build.make CMakeFiles/cmTryCompileExec2077471562.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2077471562.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec2077471562.dir/CheckIncludeFiles.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec2077471562
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2077471562.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec2077471562.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec2077471562 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining size of size_t passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3106139774/fast"
make -f CMakeFiles/cmTryCompileExec3106139774.dir/build.make CMakeFiles/cmTryCompileExec3106139774.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3106139774.dir/SIZEOF_SIZE_T.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec3106139774.dir/SIZEOF_SIZE_T.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CheckTypeSize/SIZEOF_SIZE_T.c
Linking C executable cmTryCompileExec3106139774
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3106139774.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec3106139774.dir/SIZEOF_SIZE_T.c.o  -o cmTryCompileExec3106139774 -rdynamic -ldl -lidn 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining size of ssize_t passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2044684257/fast"
make -f CMakeFiles/cmTryCompileExec2044684257.dir/build.make CMakeFiles/cmTryCompileExec2044684257.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2044684257.dir/SIZEOF_SSIZE_T.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec2044684257.dir/SIZEOF_SSIZE_T.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CheckTypeSize/SIZEOF_SSIZE_T.c
Linking C executable cmTryCompileExec2044684257
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2044684257.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec2044684257.dir/SIZEOF_SSIZE_T.c.o  -o cmTryCompileExec2044684257 -rdynamic -ldl -lidn 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining size of long long passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2323145336/fast"
make -f CMakeFiles/cmTryCompileExec2323145336.dir/build.make CMakeFiles/cmTryCompileExec2323145336.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2323145336.dir/SIZEOF_LONG_LONG.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec2323145336.dir/SIZEOF_LONG_LONG.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CheckTypeSize/SIZEOF_LONG_LONG.c
Linking C executable cmTryCompileExec2323145336
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2323145336.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec2323145336.dir/SIZEOF_LONG_LONG.c.o  -o cmTryCompileExec2323145336 -rdynamic -ldl -lidn 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining size of long passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec4218562169/fast"
make -f CMakeFiles/cmTryCompileExec4218562169.dir/build.make CMakeFiles/cmTryCompileExec4218562169.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec4218562169.dir/SIZEOF_LONG.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec4218562169.dir/SIZEOF_LONG.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CheckTypeSize/SIZEOF_LONG.c
Linking C executable cmTryCompileExec4218562169
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec4218562169.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec4218562169.dir/SIZEOF_LONG.c.o  -o cmTryCompileExec4218562169 -rdynamic -ldl -lidn 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining size of time_t passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec345672130/fast"
make -f CMakeFiles/cmTryCompileExec345672130.dir/build.make CMakeFiles/cmTryCompileExec345672130.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec345672130.dir/SIZEOF_TIME_T.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec345672130.dir/SIZEOF_TIME_T.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CheckTypeSize/SIZEOF_TIME_T.c
Linking C executable cmTryCompileExec345672130
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec345672130.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec345672130.dir/SIZEOF_TIME_T.c.o  -o cmTryCompileExec345672130 -rdynamic -ldl -lidn 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if the basename exist passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec948046537/fast"
make -f CMakeFiles/cmTryCompileExec948046537.dir/build.make CMakeFiles/cmTryCompileExec948046537.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec948046537.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec948046537.dir/CheckSymbolExists.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec948046537
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec948046537.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec948046537.dir/CheckSymbolExists.c.o  -o cmTryCompileExec948046537 -rdynamic -ldl -lidn 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'

File /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <idn-free.h>
#include <idna.h>
#include <tld.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef basename
  return ((int*)(&basename))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the socket exist passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec479629871/fast"
make -f CMakeFiles/cmTryCompileExec479629871.dir/build.make CMakeFiles/cmTryCompileExec479629871.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec479629871.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec479629871.dir/CheckSymbolExists.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec479629871
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec479629871.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec479629871.dir/CheckSymbolExists.c.o  -o cmTryCompileExec479629871 -rdynamic -ldl -lidn 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'

File /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <idn-free.h>
#include <idna.h>
#include <tld.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef socket
  return ((int*)(&socket))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the poll exist passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2742134266/fast"
make -f CMakeFiles/cmTryCompileExec2742134266.dir/build.make CMakeFiles/cmTryCompileExec2742134266.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2742134266.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec2742134266.dir/CheckSymbolExists.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec2742134266
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2742134266.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec2742134266.dir/CheckSymbolExists.c.o  -o cmTryCompileExec2742134266 -rdynamic -ldl -lidn 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'

File /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <idn-free.h>
#include <idna.h>
#include <tld.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef poll
  return ((int*)(&poll))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the select exist passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3104584305/fast"
make -f CMakeFiles/cmTryCompileExec3104584305.dir/build.make CMakeFiles/cmTryCompileExec3104584305.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3104584305.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec3104584305.dir/CheckSymbolExists.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec3104584305
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3104584305.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec3104584305.dir/CheckSymbolExists.c.o  -o cmTryCompileExec3104584305 -rdynamic -ldl -lidn 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'

File /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <idn-free.h>
#include <idna.h>
#include <tld.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef select
  return ((int*)(&select))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the strdup exist passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec763469388/fast"
make -f CMakeFiles/cmTryCompileExec763469388.dir/build.make CMakeFiles/cmTryCompileExec763469388.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec763469388.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec763469388.dir/CheckSymbolExists.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec763469388
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec763469388.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec763469388.dir/CheckSymbolExists.c.o  -o cmTryCompileExec763469388 -rdynamic -ldl -lidn 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'

File /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <idn-free.h>
#include <idna.h>
#include <tld.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef strdup
  return ((int*)(&strdup))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the strstr exist passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2385218058/fast"
make -f CMakeFiles/cmTryCompileExec2385218058.dir/build.make CMakeFiles/cmTryCompileExec2385218058.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2385218058.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec2385218058.dir/CheckSymbolExists.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec2385218058
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2385218058.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec2385218058.dir/CheckSymbolExists.c.o  -o cmTryCompileExec2385218058 -rdynamic -ldl -lidn 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'

File /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <idn-free.h>
#include <idna.h>
#include <tld.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef strstr
  return ((int*)(&strstr))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the strtok_r exist passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2573851358/fast"
make -f CMakeFiles/cmTryCompileExec2573851358.dir/build.make CMakeFiles/cmTryCompileExec2573851358.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2573851358.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec2573851358.dir/CheckSymbolExists.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec2573851358
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2573851358.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec2573851358.dir/CheckSymbolExists.c.o  -o cmTryCompileExec2573851358 -rdynamic -ldl -lidn 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'

File /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <idn-free.h>
#include <idna.h>
#include <tld.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef strtok_r
  return ((int*)(&strtok_r))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the strftime exist passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3631896177/fast"
make -f CMakeFiles/cmTryCompileExec3631896177.dir/build.make CMakeFiles/cmTryCompileExec3631896177.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3631896177.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec3631896177.dir/CheckSymbolExists.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec3631896177
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3631896177.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec3631896177.dir/CheckSymbolExists.c.o  -o cmTryCompileExec3631896177 -rdynamic -ldl -lidn 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'

File /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <idn-free.h>
#include <idna.h>
#include <tld.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef strftime
  return ((int*)(&strftime))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the uname exist passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3238281099/fast"
make -f CMakeFiles/cmTryCompileExec3238281099.dir/build.make CMakeFiles/cmTryCompileExec3238281099.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3238281099.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec3238281099.dir/CheckSymbolExists.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec3238281099
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3238281099.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec3238281099.dir/CheckSymbolExists.c.o  -o cmTryCompileExec3238281099 -rdynamic -ldl -lidn 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'

File /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <idn-free.h>
#include <idna.h>
#include <tld.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef uname
  return ((int*)(&uname))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the strcasecmp exist passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1987987115/fast"
make -f CMakeFiles/cmTryCompileExec1987987115.dir/build.make CMakeFiles/cmTryCompileExec1987987115.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1987987115.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec1987987115.dir/CheckSymbolExists.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec1987987115
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1987987115.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec1987987115.dir/CheckSymbolExists.c.o  -o cmTryCompileExec1987987115 -rdynamic -ldl -lidn 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'

File /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <idn-free.h>
#include <idna.h>
#include <tld.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef strcasecmp
  return ((int*)(&strcasecmp))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the gethostbyaddr exist passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec25770672/fast"
make -f CMakeFiles/cmTryCompileExec25770672.dir/build.make CMakeFiles/cmTryCompileExec25770672.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec25770672.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec25770672.dir/CheckSymbolExists.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec25770672
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec25770672.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec25770672.dir/CheckSymbolExists.c.o  -o cmTryCompileExec25770672 -rdynamic -ldl -lidn 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'

File /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <idn-free.h>
#include <idna.h>
#include <tld.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef gethostbyaddr
  return ((int*)(&gethostbyaddr))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the gettimeofday exist passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1374769441/fast"
make -f CMakeFiles/cmTryCompileExec1374769441.dir/build.make CMakeFiles/cmTryCompileExec1374769441.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1374769441.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec1374769441.dir/CheckSymbolExists.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec1374769441
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1374769441.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec1374769441.dir/CheckSymbolExists.c.o  -o cmTryCompileExec1374769441 -rdynamic -ldl -lidn 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'

File /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <idn-free.h>
#include <idna.h>
#include <tld.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef gettimeofday
  return ((int*)(&gettimeofday))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the inet_addr exist passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3318521403/fast"
make -f CMakeFiles/cmTryCompileExec3318521403.dir/build.make CMakeFiles/cmTryCompileExec3318521403.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3318521403.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec3318521403.dir/CheckSymbolExists.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec3318521403
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3318521403.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec3318521403.dir/CheckSymbolExists.c.o  -o cmTryCompileExec3318521403 -rdynamic -ldl -lidn 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'

File /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <idn-free.h>
#include <idna.h>
#include <tld.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef inet_addr
  return ((int*)(&inet_addr))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the inet_pton exist passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1193664387/fast"
make -f CMakeFiles/cmTryCompileExec1193664387.dir/build.make CMakeFiles/cmTryCompileExec1193664387.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1193664387.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec1193664387.dir/CheckSymbolExists.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec1193664387
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1193664387.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec1193664387.dir/CheckSymbolExists.c.o  -o cmTryCompileExec1193664387 -rdynamic -ldl -lidn 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'

File /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <idn-free.h>
#include <idna.h>
#include <tld.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef inet_pton
  return ((int*)(&inet_pton))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the inet_ntoa exist passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec248148195/fast"
make -f CMakeFiles/cmTryCompileExec248148195.dir/build.make CMakeFiles/cmTryCompileExec248148195.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec248148195.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec248148195.dir/CheckSymbolExists.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec248148195
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec248148195.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec248148195.dir/CheckSymbolExists.c.o  -o cmTryCompileExec248148195 -rdynamic -ldl -lidn 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'

File /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <idn-free.h>
#include <idna.h>
#include <tld.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef inet_ntoa
  return ((int*)(&inet_ntoa))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the tcsetattr exist passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1910082326/fast"
make -f CMakeFiles/cmTryCompileExec1910082326.dir/build.make CMakeFiles/cmTryCompileExec1910082326.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1910082326.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec1910082326.dir/CheckSymbolExists.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec1910082326
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1910082326.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec1910082326.dir/CheckSymbolExists.c.o  -o cmTryCompileExec1910082326 -rdynamic -ldl -lidn 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'

File /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <idn-free.h>
#include <idna.h>
#include <tld.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef tcsetattr
  return ((int*)(&tcsetattr))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the tcgetattr exist passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1947003877/fast"
make -f CMakeFiles/cmTryCompileExec1947003877.dir/build.make CMakeFiles/cmTryCompileExec1947003877.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1947003877.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec1947003877.dir/CheckSymbolExists.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec1947003877
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1947003877.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec1947003877.dir/CheckSymbolExists.c.o  -o cmTryCompileExec1947003877 -rdynamic -ldl -lidn 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'

File /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <idn-free.h>
#include <idna.h>
#include <tld.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef tcgetattr
  return ((int*)(&tcgetattr))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the perror exist passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3295280839/fast"
make -f CMakeFiles/cmTryCompileExec3295280839.dir/build.make CMakeFiles/cmTryCompileExec3295280839.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3295280839.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec3295280839.dir/CheckSymbolExists.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec3295280839
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3295280839.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec3295280839.dir/CheckSymbolExists.c.o  -o cmTryCompileExec3295280839 -rdynamic -ldl -lidn 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'

File /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <idn-free.h>
#include <idna.h>
#include <tld.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef perror
  return ((int*)(&perror))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the setvbuf exist passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec382962202/fast"
make -f CMakeFiles/cmTryCompileExec382962202.dir/build.make CMakeFiles/cmTryCompileExec382962202.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec382962202.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec382962202.dir/CheckSymbolExists.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec382962202
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec382962202.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec382962202.dir/CheckSymbolExists.c.o  -o cmTryCompileExec382962202 -rdynamic -ldl -lidn 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'

File /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <idn-free.h>
#include <idna.h>
#include <tld.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef setvbuf
  return ((int*)(&setvbuf))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the sigsetjmp exist passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3099557266/fast"
make -f CMakeFiles/cmTryCompileExec3099557266.dir/build.make CMakeFiles/cmTryCompileExec3099557266.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3099557266.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec3099557266.dir/CheckSymbolExists.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec3099557266
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3099557266.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec3099557266.dir/CheckSymbolExists.c.o  -o cmTryCompileExec3099557266 -rdynamic -ldl -lidn 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'

File /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <idn-free.h>
#include <idna.h>
#include <tld.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef sigsetjmp
  return ((int*)(&sigsetjmp))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the getpwuid exist passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1696280801/fast"
make -f CMakeFiles/cmTryCompileExec1696280801.dir/build.make CMakeFiles/cmTryCompileExec1696280801.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1696280801.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec1696280801.dir/CheckSymbolExists.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec1696280801
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1696280801.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec1696280801.dir/CheckSymbolExists.c.o  -o cmTryCompileExec1696280801 -rdynamic -ldl -lidn 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'

File /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <idn-free.h>
#include <idna.h>
#include <tld.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef getpwuid
  return ((int*)(&getpwuid))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the geteuid exist passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2152443264/fast"
make -f CMakeFiles/cmTryCompileExec2152443264.dir/build.make CMakeFiles/cmTryCompileExec2152443264.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2152443264.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec2152443264.dir/CheckSymbolExists.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec2152443264
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2152443264.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec2152443264.dir/CheckSymbolExists.c.o  -o cmTryCompileExec2152443264 -rdynamic -ldl -lidn 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'

File /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <idn-free.h>
#include <idna.h>
#include <tld.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef geteuid
  return ((int*)(&geteuid))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the utime exist passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2052047773/fast"
make -f CMakeFiles/cmTryCompileExec2052047773.dir/build.make CMakeFiles/cmTryCompileExec2052047773.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2052047773.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec2052047773.dir/CheckSymbolExists.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec2052047773
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2052047773.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec2052047773.dir/CheckSymbolExists.c.o  -o cmTryCompileExec2052047773 -rdynamic -ldl -lidn 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'

File /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <idn-free.h>
#include <idna.h>
#include <tld.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef utime
  return ((int*)(&utime))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the gmtime_r exist passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec466675900/fast"
make -f CMakeFiles/cmTryCompileExec466675900.dir/build.make CMakeFiles/cmTryCompileExec466675900.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec466675900.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec466675900.dir/CheckSymbolExists.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec466675900
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec466675900.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec466675900.dir/CheckSymbolExists.c.o  -o cmTryCompileExec466675900 -rdynamic -ldl -lidn 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'

File /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <idn-free.h>
#include <idna.h>
#include <tld.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef gmtime_r
  return ((int*)(&gmtime_r))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the localtime_r exist passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec4062531760/fast"
make -f CMakeFiles/cmTryCompileExec4062531760.dir/build.make CMakeFiles/cmTryCompileExec4062531760.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec4062531760.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec4062531760.dir/CheckSymbolExists.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec4062531760
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec4062531760.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec4062531760.dir/CheckSymbolExists.c.o  -o cmTryCompileExec4062531760 -rdynamic -ldl -lidn 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'

File /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <idn-free.h>
#include <idna.h>
#include <tld.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef localtime_r
  return ((int*)(&localtime_r))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the gethostbyname exist passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1888008753/fast"
make -f CMakeFiles/cmTryCompileExec1888008753.dir/build.make CMakeFiles/cmTryCompileExec1888008753.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1888008753.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec1888008753.dir/CheckSymbolExists.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec1888008753
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1888008753.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec1888008753.dir/CheckSymbolExists.c.o  -o cmTryCompileExec1888008753 -rdynamic -ldl -lidn 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'

File /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <idn-free.h>
#include <idna.h>
#include <tld.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef gethostbyname
  return ((int*)(&gethostbyname))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the gethostbyname_r exist passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec37027592/fast"
make -f CMakeFiles/cmTryCompileExec37027592.dir/build.make CMakeFiles/cmTryCompileExec37027592.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec37027592.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec37027592.dir/CheckSymbolExists.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec37027592
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec37027592.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec37027592.dir/CheckSymbolExists.c.o  -o cmTryCompileExec37027592 -rdynamic -ldl -lidn 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'

File /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <idn-free.h>
#include <idna.h>
#include <tld.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef gethostbyname_r
  return ((int*)(&gethostbyname_r))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the gethostbyaddr_r exist passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2061681855/fast"
make -f CMakeFiles/cmTryCompileExec2061681855.dir/build.make CMakeFiles/cmTryCompileExec2061681855.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2061681855.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec2061681855.dir/CheckSymbolExists.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec2061681855
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2061681855.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec2061681855.dir/CheckSymbolExists.c.o  -o cmTryCompileExec2061681855 -rdynamic -ldl -lidn 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'

File /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <idn-free.h>
#include <idna.h>
#include <tld.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef gethostbyaddr_r
  return ((int*)(&gethostbyaddr_r))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the signal exist passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1800398651/fast"
make -f CMakeFiles/cmTryCompileExec1800398651.dir/build.make CMakeFiles/cmTryCompileExec1800398651.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1800398651.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec1800398651.dir/CheckSymbolExists.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec1800398651
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1800398651.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec1800398651.dir/CheckSymbolExists.c.o  -o cmTryCompileExec1800398651 -rdynamic -ldl -lidn 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'

File /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <idn-free.h>
#include <idna.h>
#include <tld.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef signal
  return ((int*)(&signal))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the SIGALRM exist passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3450958071/fast"
make -f CMakeFiles/cmTryCompileExec3450958071.dir/build.make CMakeFiles/cmTryCompileExec3450958071.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3450958071.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec3450958071.dir/CheckSymbolExists.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec3450958071
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3450958071.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec3450958071.dir/CheckSymbolExists.c.o  -o cmTryCompileExec3450958071 -rdynamic -ldl -lidn 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'

File /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <idn-free.h>
#include <idna.h>
#include <tld.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef SIGALRM
  return ((int*)(&SIGALRM))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the strtoll exist passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2647750962/fast"
make -f CMakeFiles/cmTryCompileExec2647750962.dir/build.make CMakeFiles/cmTryCompileExec2647750962.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2647750962.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec2647750962.dir/CheckSymbolExists.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec2647750962
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2647750962.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec2647750962.dir/CheckSymbolExists.c.o  -o cmTryCompileExec2647750962 -rdynamic -ldl -lidn 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'

File /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <idn-free.h>
#include <idna.h>
#include <tld.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef strtoll
  return ((int*)(&strtoll))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the strerror_r exist passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3253429658/fast"
make -f CMakeFiles/cmTryCompileExec3253429658.dir/build.make CMakeFiles/cmTryCompileExec3253429658.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3253429658.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec3253429658.dir/CheckSymbolExists.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec3253429658
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3253429658.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec3253429658.dir/CheckSymbolExists.c.o  -o cmTryCompileExec3253429658 -rdynamic -ldl -lidn 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'

File /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <idn-free.h>
#include <idna.h>
#include <tld.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef strerror_r
  return ((int*)(&strerror_r))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the siginterrupt exist passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1100020204/fast"
make -f CMakeFiles/cmTryCompileExec1100020204.dir/build.make CMakeFiles/cmTryCompileExec1100020204.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1100020204.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec1100020204.dir/CheckSymbolExists.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec1100020204
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1100020204.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec1100020204.dir/CheckSymbolExists.c.o  -o cmTryCompileExec1100020204 -rdynamic -ldl -lidn 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'

File /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <idn-free.h>
#include <idna.h>
#include <tld.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef siginterrupt
  return ((int*)(&siginterrupt))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the fork exist passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3885771132/fast"
make -f CMakeFiles/cmTryCompileExec3885771132.dir/build.make CMakeFiles/cmTryCompileExec3885771132.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3885771132.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec3885771132.dir/CheckSymbolExists.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec3885771132
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3885771132.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec3885771132.dir/CheckSymbolExists.c.o  -o cmTryCompileExec3885771132 -rdynamic -ldl -lidn 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'

File /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <idn-free.h>
#include <idna.h>
#include <tld.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef fork
  return ((int*)(&fork))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the pipe exist passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec106320697/fast"
make -f CMakeFiles/cmTryCompileExec106320697.dir/build.make CMakeFiles/cmTryCompileExec106320697.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec106320697.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec106320697.dir/CheckSymbolExists.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec106320697
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec106320697.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec106320697.dir/CheckSymbolExists.c.o  -o cmTryCompileExec106320697 -rdynamic -ldl -lidn 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'

File /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <idn-free.h>
#include <idna.h>
#include <tld.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef pipe
  return ((int*)(&pipe))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the ftruncate exist passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2523483159/fast"
make -f CMakeFiles/cmTryCompileExec2523483159.dir/build.make CMakeFiles/cmTryCompileExec2523483159.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2523483159.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec2523483159.dir/CheckSymbolExists.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec2523483159
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2523483159.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec2523483159.dir/CheckSymbolExists.c.o  -o cmTryCompileExec2523483159 -rdynamic -ldl -lidn 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'

File /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <idn-free.h>
#include <idna.h>
#include <tld.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef ftruncate
  return ((int*)(&ftruncate))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the getprotobyname exist passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2193017479/fast"
make -f CMakeFiles/cmTryCompileExec2193017479.dir/build.make CMakeFiles/cmTryCompileExec2193017479.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2193017479.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec2193017479.dir/CheckSymbolExists.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec2193017479
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2193017479.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec2193017479.dir/CheckSymbolExists.c.o  -o cmTryCompileExec2193017479 -rdynamic -ldl -lidn 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'

File /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <idn-free.h>
#include <idna.h>
#include <tld.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef getprotobyname
  return ((int*)(&getprotobyname))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the getrlimit exist passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec4025422952/fast"
make -f CMakeFiles/cmTryCompileExec4025422952.dir/build.make CMakeFiles/cmTryCompileExec4025422952.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec4025422952.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec4025422952.dir/CheckSymbolExists.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec4025422952
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec4025422952.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec4025422952.dir/CheckSymbolExists.c.o  -o cmTryCompileExec4025422952 -rdynamic -ldl -lidn 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'

File /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <idn-free.h>
#include <idna.h>
#include <tld.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef getrlimit
  return ((int*)(&getrlimit))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the idn_free exist passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec4219431100/fast"
make -f CMakeFiles/cmTryCompileExec4219431100.dir/build.make CMakeFiles/cmTryCompileExec4219431100.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec4219431100.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec4219431100.dir/CheckSymbolExists.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec4219431100
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec4219431100.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec4219431100.dir/CheckSymbolExists.c.o  -o cmTryCompileExec4219431100 -rdynamic -ldl -lidn 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'

File /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <idn-free.h>
#include <idna.h>
#include <tld.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef idn_free
  return ((int*)(&idn_free))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the idna_strerror exist passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3897560983/fast"
make -f CMakeFiles/cmTryCompileExec3897560983.dir/build.make CMakeFiles/cmTryCompileExec3897560983.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3897560983.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec3897560983.dir/CheckSymbolExists.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec3897560983
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3897560983.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec3897560983.dir/CheckSymbolExists.c.o  -o cmTryCompileExec3897560983 -rdynamic -ldl -lidn 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'

File /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <idn-free.h>
#include <idna.h>
#include <tld.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef idna_strerror
  return ((int*)(&idna_strerror))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the tld_strerror exist passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec411258101/fast"
make -f CMakeFiles/cmTryCompileExec411258101.dir/build.make CMakeFiles/cmTryCompileExec411258101.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec411258101.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec411258101.dir/CheckSymbolExists.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec411258101
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec411258101.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec411258101.dir/CheckSymbolExists.c.o  -o cmTryCompileExec411258101 -rdynamic -ldl -lidn 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'

File /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <idn-free.h>
#include <idna.h>
#include <tld.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef tld_strerror
  return ((int*)(&tld_strerror))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the setlocale exist passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3839438438/fast"
make -f CMakeFiles/cmTryCompileExec3839438438.dir/build.make CMakeFiles/cmTryCompileExec3839438438.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3839438438.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec3839438438.dir/CheckSymbolExists.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec3839438438
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3839438438.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec3839438438.dir/CheckSymbolExists.c.o  -o cmTryCompileExec3839438438 -rdynamic -ldl -lidn 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'

File /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <idn-free.h>
#include <idna.h>
#include <tld.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef setlocale
  return ((int*)(&setlocale))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the setrlimit exist passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3047190231/fast"
make -f CMakeFiles/cmTryCompileExec3047190231.dir/build.make CMakeFiles/cmTryCompileExec3047190231.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3047190231.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec3047190231.dir/CheckSymbolExists.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec3047190231
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3047190231.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec3047190231.dir/CheckSymbolExists.c.o  -o cmTryCompileExec3047190231 -rdynamic -ldl -lidn 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'

File /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <idn-free.h>
#include <idna.h>
#include <tld.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef setrlimit
  return ((int*)(&setrlimit))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the sigaction exist passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3873295356/fast"
make -f CMakeFiles/cmTryCompileExec3873295356.dir/build.make CMakeFiles/cmTryCompileExec3873295356.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3873295356.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec3873295356.dir/CheckSymbolExists.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec3873295356
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3873295356.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec3873295356.dir/CheckSymbolExists.c.o  -o cmTryCompileExec3873295356 -rdynamic -ldl -lidn 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'

File /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <signal.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef sigaction
  return ((int*)(&sigaction))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Performing Curl Test HAVE_O_NONBLOCK passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2793116571/fast"
make -f CMakeFiles/cmTryCompileExec2793116571.dir/build.make CMakeFiles/cmTryCompileExec2793116571.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2793116571.dir/CurlTests.c.o
/usr/bin/gcc   -DHAVE_O_NONBLOCK   -o CMakeFiles/cmTryCompileExec2793116571.dir/CurlTests.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Utilities/cmcurl/CMake/CurlTests.c
Linking C executable cmTryCompileExec2793116571
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2793116571.dir/link.txt --verbose=1
/usr/bin/gcc      -DHAVE_O_NONBLOCK    CMakeFiles/cmTryCompileExec2793116571.dir/CurlTests.c.o  -o cmTryCompileExec2793116571 -rdynamic -ldl -lidn 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'

Performing Curl Test TIME_WITH_SYS_TIME passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec175316061/fast"
make -f CMakeFiles/cmTryCompileExec175316061.dir/build.make CMakeFiles/cmTryCompileExec175316061.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec175316061.dir/CurlTests.c.o
/usr/bin/gcc   -DTIME_WITH_SYS_TIME   -o CMakeFiles/cmTryCompileExec175316061.dir/CurlTests.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Utilities/cmcurl/CMake/CurlTests.c
Linking C executable cmTryCompileExec175316061
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec175316061.dir/link.txt --verbose=1
/usr/bin/gcc      -DTIME_WITH_SYS_TIME    CMakeFiles/cmTryCompileExec175316061.dir/CurlTests.c.o  -o cmTryCompileExec175316061 -rdynamic -ldl -lidn 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'

Performing Curl Test HAVE_GETHOSTBYADDR_R_8 passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3169974284/fast"
make -f CMakeFiles/cmTryCompileExec3169974284.dir/build.make CMakeFiles/cmTryCompileExec3169974284.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3169974284.dir/CurlTests.c.o
/usr/bin/gcc   -DHAVE_GETHOSTBYADDR_R_8   -o CMakeFiles/cmTryCompileExec3169974284.dir/CurlTests.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Utilities/cmcurl/CMake/CurlTests.c
Linking C executable cmTryCompileExec3169974284
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3169974284.dir/link.txt --verbose=1
/usr/bin/gcc      -DHAVE_GETHOSTBYADDR_R_8    CMakeFiles/cmTryCompileExec3169974284.dir/CurlTests.c.o  -o cmTryCompileExec3169974284 -rdynamic -ldl -lidn 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'

Performing Curl Test HAVE_GETHOSTBYADDR_R_8_REENTRANT passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3295374734/fast"
make -f CMakeFiles/cmTryCompileExec3295374734.dir/build.make CMakeFiles/cmTryCompileExec3295374734.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3295374734.dir/CurlTests.c.o
/usr/bin/gcc   -DHAVE_GETHOSTBYADDR_R_8_REENTRANT   -o CMakeFiles/cmTryCompileExec3295374734.dir/CurlTests.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Utilities/cmcurl/CMake/CurlTests.c
Linking C executable cmTryCompileExec3295374734
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3295374734.dir/link.txt --verbose=1
/usr/bin/gcc      -DHAVE_GETHOSTBYADDR_R_8_REENTRANT    CMakeFiles/cmTryCompileExec3295374734.dir/CurlTests.c.o  -o cmTryCompileExec3295374734 -rdynamic -ldl -lidn 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'

Performing Curl Test HAVE_GETHOSTBYNAME_R_6 passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3620779363/fast"
make -f CMakeFiles/cmTryCompileExec3620779363.dir/build.make CMakeFiles/cmTryCompileExec3620779363.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3620779363.dir/CurlTests.c.o
/usr/bin/gcc   -DHAVE_GETHOSTBYNAME_R_6   -o CMakeFiles/cmTryCompileExec3620779363.dir/CurlTests.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Utilities/cmcurl/CMake/CurlTests.c
Linking C executable cmTryCompileExec3620779363
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3620779363.dir/link.txt --verbose=1
/usr/bin/gcc      -DHAVE_GETHOSTBYNAME_R_6    CMakeFiles/cmTryCompileExec3620779363.dir/CurlTests.c.o  -o cmTryCompileExec3620779363 -rdynamic -ldl -lidn 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'

Performing Curl Test HAVE_GETHOSTBYNAME_R_6_REENTRANT passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3545507803/fast"
make -f CMakeFiles/cmTryCompileExec3545507803.dir/build.make CMakeFiles/cmTryCompileExec3545507803.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3545507803.dir/CurlTests.c.o
/usr/bin/gcc   -DHAVE_GETHOSTBYNAME_R_6_REENTRANT   -o CMakeFiles/cmTryCompileExec3545507803.dir/CurlTests.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Utilities/cmcurl/CMake/CurlTests.c
Linking C executable cmTryCompileExec3545507803
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3545507803.dir/link.txt --verbose=1
/usr/bin/gcc      -DHAVE_GETHOSTBYNAME_R_6_REENTRANT    CMakeFiles/cmTryCompileExec3545507803.dir/CurlTests.c.o  -o cmTryCompileExec3545507803 -rdynamic -ldl -lidn 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'

Performing Curl Test HAVE_SOCKLEN_T passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec338997885/fast"
make -f CMakeFiles/cmTryCompileExec338997885.dir/build.make CMakeFiles/cmTryCompileExec338997885.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec338997885.dir/CurlTests.c.o
/usr/bin/gcc   -DHAVE_SOCKLEN_T   -o CMakeFiles/cmTryCompileExec338997885.dir/CurlTests.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Utilities/cmcurl/CMake/CurlTests.c
Linking C executable cmTryCompileExec338997885
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec338997885.dir/link.txt --verbose=1
/usr/bin/gcc      -DHAVE_SOCKLEN_T    CMakeFiles/cmTryCompileExec338997885.dir/CurlTests.c.o  -o cmTryCompileExec338997885 -rdynamic -ldl -lidn 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'

Performing Curl Test HAVE_IN_ADDR_T passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1369487549/fast"
make -f CMakeFiles/cmTryCompileExec1369487549.dir/build.make CMakeFiles/cmTryCompileExec1369487549.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1369487549.dir/CurlTests.c.o
/usr/bin/gcc   -DHAVE_IN_ADDR_T   -o CMakeFiles/cmTryCompileExec1369487549.dir/CurlTests.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Utilities/cmcurl/CMake/CurlTests.c
Linking C executable cmTryCompileExec1369487549
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1369487549.dir/link.txt --verbose=1
/usr/bin/gcc      -DHAVE_IN_ADDR_T    CMakeFiles/cmTryCompileExec1369487549.dir/CurlTests.c.o  -o cmTryCompileExec1369487549 -rdynamic -ldl -lidn 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'

Performing Curl Test STDC_HEADERS passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec295971603/fast"
make -f CMakeFiles/cmTryCompileExec295971603.dir/build.make CMakeFiles/cmTryCompileExec295971603.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec295971603.dir/CurlTests.c.o
/usr/bin/gcc   -DSTDC_HEADERS   -o CMakeFiles/cmTryCompileExec295971603.dir/CurlTests.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Utilities/cmcurl/CMake/CurlTests.c
Linking C executable cmTryCompileExec295971603
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec295971603.dir/link.txt --verbose=1
/usr/bin/gcc      -DSTDC_HEADERS    CMakeFiles/cmTryCompileExec295971603.dir/CurlTests.c.o  -o cmTryCompileExec295971603 -rdynamic -ldl -lidn 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'

Performing Curl Test RETSIGTYPE_TEST passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec778195184/fast"
make -f CMakeFiles/cmTryCompileExec778195184.dir/build.make CMakeFiles/cmTryCompileExec778195184.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec778195184.dir/CurlTests.c.o
/usr/bin/gcc   -DRETSIGTYPE_TEST   -o CMakeFiles/cmTryCompileExec778195184.dir/CurlTests.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Utilities/cmcurl/CMake/CurlTests.c
Linking C executable cmTryCompileExec778195184
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec778195184.dir/link.txt --verbose=1
/usr/bin/gcc      -DRETSIGTYPE_TEST    CMakeFiles/cmTryCompileExec778195184.dir/CurlTests.c.o  -o cmTryCompileExec778195184 -rdynamic -ldl -lidn 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'

Performing Curl Test HAVE_GETADDRINFO passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1009828648/fast"
make -f CMakeFiles/cmTryCompileExec1009828648.dir/build.make CMakeFiles/cmTryCompileExec1009828648.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1009828648.dir/CurlTests.c.o
/usr/bin/gcc   -DHAVE_GETADDRINFO   -o CMakeFiles/cmTryCompileExec1009828648.dir/CurlTests.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Utilities/cmcurl/CMake/CurlTests.c
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Utilities/cmcurl/CMake/CurlTests.c: In function ‘main’:
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Utilities/cmcurl/CMake/CurlTests.c:405: warning: incompatible implicit declaration of built-in function ‘memset’
Linking C executable cmTryCompileExec1009828648
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1009828648.dir/link.txt --verbose=1
/usr/bin/gcc      -DHAVE_GETADDRINFO    CMakeFiles/cmTryCompileExec1009828648.dir/CurlTests.c.o  -o cmTryCompileExec1009828648 -rdynamic -ldl -lidn 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'

Performing Curl Test HAVE_FILE_OFFSET_BITS passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1724880584/fast"
make -f CMakeFiles/cmTryCompileExec1724880584.dir/build.make CMakeFiles/cmTryCompileExec1724880584.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1724880584.dir/CurlTests.c.o
/usr/bin/gcc   -DHAVE_FILE_OFFSET_BITS   -o CMakeFiles/cmTryCompileExec1724880584.dir/CurlTests.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Utilities/cmcurl/CMake/CurlTests.c
Linking C executable cmTryCompileExec1724880584
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1724880584.dir/link.txt --verbose=1
/usr/bin/gcc      -DHAVE_FILE_OFFSET_BITS    CMakeFiles/cmTryCompileExec1724880584.dir/CurlTests.c.o  -o cmTryCompileExec1724880584 -rdynamic -ldl -lidn 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'

Determining size of curl_off_t passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3569243143/fast"
make -f CMakeFiles/cmTryCompileExec3569243143.dir/build.make CMakeFiles/cmTryCompileExec3569243143.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3569243143.dir/SIZEOF_CURL_OFF_T.c.o
/usr/bin/gcc   -D_FILE_OFFSET_BITS=64   -o CMakeFiles/cmTryCompileExec3569243143.dir/SIZEOF_CURL_OFF_T.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CheckTypeSize/SIZEOF_CURL_OFF_T.c
Linking C executable cmTryCompileExec3569243143
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3569243143.dir/link.txt --verbose=1
/usr/bin/gcc      -D_FILE_OFFSET_BITS=64    CMakeFiles/cmTryCompileExec3569243143.dir/SIZEOF_CURL_OFF_T.c.o  -o cmTryCompileExec3569243143 -rdynamic -ldl -lidn 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Performing C SOURCE FILE Test curl_cv_recv succeded with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3828004245/fast"
make -f CMakeFiles/cmTryCompileExec3828004245.dir/build.make CMakeFiles/cmTryCompileExec3828004245.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3828004245.dir/src.c.o
/usr/bin/gcc   -Dcurl_cv_recv   -o CMakeFiles/cmTryCompileExec3828004245.dir/src.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/src.c
Linking C executable cmTryCompileExec3828004245
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3828004245.dir/link.txt --verbose=1
/usr/bin/gcc      -Dcurl_cv_recv    CMakeFiles/cmTryCompileExec3828004245.dir/src.c.o  -o cmTryCompileExec3828004245 -rdynamic -ldl -lidn 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'

Source file was:
#define __unused1
#undef inline
#define __unused2

#include <sys/types.h>
#include <sys/socket.h>

#define __unused5 1

int main() { recv(0, 0, 0, 0) ; return 0; }
Performing C SOURCE FILE Test ssize_t recv(int, void *, size_t, int) (curl_cv_func_recv_test) succeded with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2070090636/fast"
make -f CMakeFiles/cmTryCompileExec2070090636.dir/build.make CMakeFiles/cmTryCompileExec2070090636.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2070090636.dir/src.c.o
/usr/bin/gcc   -Dcurl_cv_func_recv_test   -o CMakeFiles/cmTryCompileExec2070090636.dir/src.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/src.c
Linking C executable cmTryCompileExec2070090636
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2070090636.dir/link.txt --verbose=1
/usr/bin/gcc      -Dcurl_cv_func_recv_test    CMakeFiles/cmTryCompileExec2070090636.dir/src.c.o  -o cmTryCompileExec2070090636 -rdynamic -ldl -lidn 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'

Source file was:
#define __unused1
#undef inline
#define __unused2

#include <sys/types.h>
#include <sys/socket.h>
extern ssize_t  recv(int, void *, size_t, int);
#define __unused5 1

int main() { 
                    int s=0;
                    void * buf=0;
                    size_t len=0;
                    int flags=0;
                    ssize_t res = recv(s, buf, len, flags) ; return 0; }
Performing C SOURCE FILE Test curl_cv_send succeded with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2842537089/fast"
make -f CMakeFiles/cmTryCompileExec2842537089.dir/build.make CMakeFiles/cmTryCompileExec2842537089.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2842537089.dir/src.c.o
/usr/bin/gcc   -Dcurl_cv_send   -o CMakeFiles/cmTryCompileExec2842537089.dir/src.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/src.c
Linking C executable cmTryCompileExec2842537089
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2842537089.dir/link.txt --verbose=1
/usr/bin/gcc      -Dcurl_cv_send    CMakeFiles/cmTryCompileExec2842537089.dir/src.c.o  -o cmTryCompileExec2842537089 -rdynamic -ldl -lidn 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'

Source file was:
#define __unused1
#undef inline
#define __unused2

#include <sys/types.h>
#include <sys/socket.h>
extern ssize_t  recv(int, void *, size_t, int);
#define __unused5 1

int main() { send(0, 0, 0, 0) ; return 0; }
Performing C SOURCE FILE Test ssize_t send(int, const void *, size_t, int) (curl_cv_func_send_test) succeded with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec4095735006/fast"
make -f CMakeFiles/cmTryCompileExec4095735006.dir/build.make CMakeFiles/cmTryCompileExec4095735006.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec4095735006.dir/src.c.o
/usr/bin/gcc   -Dcurl_cv_func_send_test   -o CMakeFiles/cmTryCompileExec4095735006.dir/src.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/src.c
Linking C executable cmTryCompileExec4095735006
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec4095735006.dir/link.txt --verbose=1
/usr/bin/gcc      -Dcurl_cv_func_send_test    CMakeFiles/cmTryCompileExec4095735006.dir/src.c.o  -o cmTryCompileExec4095735006 -rdynamic -ldl -lidn 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'

Source file was:
#define __unused1
#undef inline
#define __unused2

#include <sys/types.h>
#include <sys/socket.h>
extern ssize_t  send(int, const void *, size_t, int);
#define __unused5 1

int main() { 
                    int s=0;
                    const void * buf=0;
                    size_t len=0;
                    int flags=0;
                    ssize_t res = send(s, buf, len, flags) ; return 0; }
Performing C SOURCE FILE Test HAVE_MSG_NOSIGNAL succeded with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec4277575177/fast"
make -f CMakeFiles/cmTryCompileExec4277575177.dir/build.make CMakeFiles/cmTryCompileExec4277575177.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec4277575177.dir/src.c.o
/usr/bin/gcc   -DHAVE_MSG_NOSIGNAL   -o CMakeFiles/cmTryCompileExec4277575177.dir/src.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/src.c
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/src.c:12:1: warning: "__unused5" redefined
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/src.c:8:1: warning: this is the location of the previous definition
Linking C executable cmTryCompileExec4277575177
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec4277575177.dir/link.txt --verbose=1
/usr/bin/gcc      -DHAVE_MSG_NOSIGNAL    CMakeFiles/cmTryCompileExec4277575177.dir/src.c.o  -o cmTryCompileExec4277575177 -rdynamic -ldl -lidn 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'

Source file was:
#define __unused1
#undef inline
#define __unused2

#include <sys/types.h>
#include <sys/socket.h>
extern ssize_t  send(int, const void *, size_t, int);
#define __unused5

#include <sys/types.h>
#include <sys/socket.h>
#define __unused5 1

int main() { int flag = MSG_NOSIGNAL ; return 0; }
Performing C SOURCE FILE Test HAVE_STRUCT_TIMEVAL succeded with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3333582658/fast"
make -f CMakeFiles/cmTryCompileExec3333582658.dir/build.make CMakeFiles/cmTryCompileExec3333582658.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3333582658.dir/src.c.o
/usr/bin/gcc   -DHAVE_STRUCT_TIMEVAL   -o CMakeFiles/cmTryCompileExec3333582658.dir/src.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/src.c
Linking C executable cmTryCompileExec3333582658
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3333582658.dir/link.txt --verbose=1
/usr/bin/gcc      -DHAVE_STRUCT_TIMEVAL    CMakeFiles/cmTryCompileExec3333582658.dir/src.c.o  -o cmTryCompileExec3333582658 -rdynamic -ldl -lidn 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'

Source file was:
#define __unused1
#undef inline
#define __unused2

#include <sys/types.h>
#include <sys/time.h>
#include <time.h>
#include <time.h>
#define __unused5 1

int main() { struct timeval ts;
ts.tv_sec  = 0;
ts.tv_usec = 0 ; return 0; }
Determining size of sig_atomic_t passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3145445314/fast"
make -f CMakeFiles/cmTryCompileExec3145445314.dir/build.make CMakeFiles/cmTryCompileExec3145445314.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3145445314.dir/SIZEOF_SIG_ATOMIC_T.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec3145445314.dir/SIZEOF_SIG_ATOMIC_T.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CheckTypeSize/SIZEOF_SIG_ATOMIC_T.c
Linking C executable cmTryCompileExec3145445314
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3145445314.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec3145445314.dir/SIZEOF_SIG_ATOMIC_T.c.o  -o cmTryCompileExec3145445314 -rdynamic -ldl -lidn 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Performing C SOURCE FILE Test HAVE_SIG_ATOMIC_T_NOT_VOLATILE succeded with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1058906574/fast"
make -f CMakeFiles/cmTryCompileExec1058906574.dir/build.make CMakeFiles/cmTryCompileExec1058906574.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1058906574.dir/src.c.o
/usr/bin/gcc   -DHAVE_SIG_ATOMIC_T_NOT_VOLATILE   -o CMakeFiles/cmTryCompileExec1058906574.dir/src.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/src.c
Linking C executable cmTryCompileExec1058906574
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1058906574.dir/link.txt --verbose=1
/usr/bin/gcc      -DHAVE_SIG_ATOMIC_T_NOT_VOLATILE    CMakeFiles/cmTryCompileExec1058906574.dir/src.c.o  -o cmTryCompileExec1058906574 -rdynamic -ldl -lidn 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'

Source file was:
#include <signal.h>

int main() { static volatile sig_atomic_t dummy = 0 ; return 0; }
Determining size of struct sockaddr_storage passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec4275166469/fast"
make -f CMakeFiles/cmTryCompileExec4275166469.dir/build.make CMakeFiles/cmTryCompileExec4275166469.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec4275166469.dir/SIZEOF_STRUCT_SOCKADDR_STORAGE.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec4275166469.dir/SIZEOF_STRUCT_SOCKADDR_STORAGE.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CheckTypeSize/SIZEOF_STRUCT_SOCKADDR_STORAGE.c
Linking C executable cmTryCompileExec4275166469
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec4275166469.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec4275166469.dir/SIZEOF_STRUCT_SOCKADDR_STORAGE.c.o  -o cmTryCompileExec4275166469 -rdynamic -ldl -lidn 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Performing C SOURCE FILE Test HAVE_DIRENT_H succeded with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2788032944/fast"
make -f CMakeFiles/cmTryCompileExec2788032944.dir/build.make CMakeFiles/cmTryCompileExec2788032944.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2788032944.dir/src.c.o
/usr/bin/gcc   -w  -DHAVE_DIRENT_H   -o CMakeFiles/cmTryCompileExec2788032944.dir/src.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/src.c
Linking C executable cmTryCompileExec2788032944
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2788032944.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DHAVE_DIRENT_H    CMakeFiles/cmTryCompileExec2788032944.dir/src.c.o  -o cmTryCompileExec2788032944 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'

Source file was:

#include <dirent.h>

int main()
{
   static DIR * tmp;
   if (sizeof(tmp))
      return 0;
  return 0;
}

Determining if files sys/types.h;ctype.h exist passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2743515416/fast"
make -f CMakeFiles/cmTryCompileExec2743515416.dir/build.make CMakeFiles/cmTryCompileExec2743515416.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2743515416.dir/CheckIncludeFiles.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec2743515416.dir/CheckIncludeFiles.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec2743515416
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2743515416.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec2743515416.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec2743515416 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if files sys/types.h;ctype.h;dlfcn.h;errno.h;fcntl.h;grp.h exist passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1975410365/fast"
make -f CMakeFiles/cmTryCompileExec1975410365.dir/build.make CMakeFiles/cmTryCompileExec1975410365.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1975410365.dir/CheckIncludeFiles.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec1975410365.dir/CheckIncludeFiles.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec1975410365
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1975410365.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec1975410365.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec1975410365 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if files sys/types.h;ctype.h;dlfcn.h;errno.h;fcntl.h;grp.h;inttypes.h;langinfo.h exist passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3024315273/fast"
make -f CMakeFiles/cmTryCompileExec3024315273.dir/build.make CMakeFiles/cmTryCompileExec3024315273.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3024315273.dir/CheckIncludeFiles.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec3024315273.dir/CheckIncludeFiles.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec3024315273
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3024315273.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec3024315273.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec3024315273 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if files sys/types.h;ctype.h;dlfcn.h;errno.h;fcntl.h;grp.h;inttypes.h;langinfo.h;limits.h;linux/types.h exist passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1634367301/fast"
make -f CMakeFiles/cmTryCompileExec1634367301.dir/build.make CMakeFiles/cmTryCompileExec1634367301.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1634367301.dir/CheckIncludeFiles.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec1634367301.dir/CheckIncludeFiles.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec1634367301
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1634367301.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec1634367301.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec1634367301 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if files sys/types.h;ctype.h;dlfcn.h;errno.h;fcntl.h;grp.h;inttypes.h;langinfo.h;limits.h;linux/types.h;linux/fiemap.h exist passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec478663909/fast"
make -f CMakeFiles/cmTryCompileExec478663909.dir/build.make CMakeFiles/cmTryCompileExec478663909.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec478663909.dir/CheckIncludeFiles.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec478663909.dir/CheckIncludeFiles.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec478663909
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec478663909.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec478663909.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec478663909 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if files sys/types.h;ctype.h;dlfcn.h;errno.h;fcntl.h;grp.h;inttypes.h;langinfo.h;limits.h;linux/types.h;linux/fiemap.h;linux/fs.h exist passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec271565239/fast"
make -f CMakeFiles/cmTryCompileExec271565239.dir/build.make CMakeFiles/cmTryCompileExec271565239.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec271565239.dir/CheckIncludeFiles.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec271565239.dir/CheckIncludeFiles.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec271565239
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec271565239.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec271565239.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec271565239 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if files sys/types.h;ctype.h;dlfcn.h;errno.h;fcntl.h;grp.h;inttypes.h;langinfo.h;limits.h;linux/types.h;linux/fiemap.h;linux/fs.h;linux/magic.h exist passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3271453769/fast"
make -f CMakeFiles/cmTryCompileExec3271453769.dir/build.make CMakeFiles/cmTryCompileExec3271453769.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3271453769.dir/CheckIncludeFiles.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec3271453769.dir/CheckIncludeFiles.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec3271453769
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3271453769.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec3271453769.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec3271453769 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if files sys/types.h;ctype.h;dlfcn.h;errno.h;fcntl.h;grp.h;inttypes.h;langinfo.h;limits.h;linux/types.h;linux/fiemap.h;linux/fs.h;linux/magic.h;locale.h;memory.h;paths.h exist passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec407008460/fast"
make -f CMakeFiles/cmTryCompileExec407008460.dir/build.make CMakeFiles/cmTryCompileExec407008460.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec407008460.dir/CheckIncludeFiles.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec407008460.dir/CheckIncludeFiles.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec407008460
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec407008460.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec407008460.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec407008460 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if files sys/types.h;ctype.h;dlfcn.h;errno.h;fcntl.h;grp.h;inttypes.h;langinfo.h;limits.h;linux/types.h;linux/fiemap.h;linux/fs.h;linux/magic.h;locale.h;memory.h;paths.h;poll.h exist passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1702236689/fast"
make -f CMakeFiles/cmTryCompileExec1702236689.dir/build.make CMakeFiles/cmTryCompileExec1702236689.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1702236689.dir/CheckIncludeFiles.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec1702236689.dir/CheckIncludeFiles.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec1702236689
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1702236689.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec1702236689.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec1702236689 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if files sys/types.h;ctype.h;dlfcn.h;errno.h;fcntl.h;grp.h;inttypes.h;langinfo.h;limits.h;linux/types.h;linux/fiemap.h;linux/fs.h;linux/magic.h;locale.h;memory.h;paths.h;poll.h;pwd.h;regex.h exist passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1399115098/fast"
make -f CMakeFiles/cmTryCompileExec1399115098.dir/build.make CMakeFiles/cmTryCompileExec1399115098.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1399115098.dir/CheckIncludeFiles.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec1399115098.dir/CheckIncludeFiles.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec1399115098
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1399115098.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec1399115098.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec1399115098 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if files sys/types.h;ctype.h;dlfcn.h;errno.h;fcntl.h;grp.h;inttypes.h;langinfo.h;limits.h;linux/types.h;linux/fiemap.h;linux/fs.h;linux/magic.h;locale.h;memory.h;paths.h;poll.h;pwd.h;regex.h;signal.h;stdarg.h exist passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec257350443/fast"
make -f CMakeFiles/cmTryCompileExec257350443.dir/build.make CMakeFiles/cmTryCompileExec257350443.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec257350443.dir/CheckIncludeFiles.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec257350443.dir/CheckIncludeFiles.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec257350443
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec257350443.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec257350443.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec257350443 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if files sys/types.h;ctype.h;dlfcn.h;errno.h;fcntl.h;grp.h;inttypes.h;langinfo.h;limits.h;linux/types.h;linux/fiemap.h;linux/fs.h;linux/magic.h;locale.h;memory.h;paths.h;poll.h;pwd.h;regex.h;signal.h;stdarg.h;stdint.h;stdlib.h;string.h;strings.h;sys/cdefs.h exist passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3685777821/fast"
make -f CMakeFiles/cmTryCompileExec3685777821.dir/build.make CMakeFiles/cmTryCompileExec3685777821.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3685777821.dir/CheckIncludeFiles.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec3685777821.dir/CheckIncludeFiles.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec3685777821
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3685777821.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec3685777821.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec3685777821 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if files sys/types.h;ctype.h;dlfcn.h;errno.h;fcntl.h;grp.h;inttypes.h;langinfo.h;limits.h;linux/types.h;linux/fiemap.h;linux/fs.h;linux/magic.h;locale.h;memory.h;paths.h;poll.h;pwd.h;regex.h;signal.h;stdarg.h;stdint.h;stdlib.h;string.h;strings.h;sys/cdefs.h;sys/ioctl.h;sys/param.h;sys/poll.h;sys/select.h;sys/stat.h;sys/statfs.h exist passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3881491266/fast"
make -f CMakeFiles/cmTryCompileExec3881491266.dir/build.make CMakeFiles/cmTryCompileExec3881491266.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3881491266.dir/CheckIncludeFiles.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec3881491266.dir/CheckIncludeFiles.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec3881491266
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3881491266.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec3881491266.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec3881491266 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if files sys/types.h;ctype.h;dlfcn.h;errno.h;fcntl.h;grp.h;inttypes.h;langinfo.h;limits.h;linux/types.h;linux/fiemap.h;linux/fs.h;linux/magic.h;locale.h;memory.h;paths.h;poll.h;pwd.h;regex.h;signal.h;stdarg.h;stdint.h;stdlib.h;string.h;strings.h;sys/cdefs.h;sys/ioctl.h;sys/param.h;sys/poll.h;sys/select.h;sys/stat.h;sys/statfs.h;sys/statvfs.h exist passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3205343402/fast"
make -f CMakeFiles/cmTryCompileExec3205343402.dir/build.make CMakeFiles/cmTryCompileExec3205343402.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3205343402.dir/CheckIncludeFiles.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec3205343402.dir/CheckIncludeFiles.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec3205343402
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3205343402.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec3205343402.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec3205343402 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if files sys/types.h;ctype.h;dlfcn.h;errno.h;fcntl.h;grp.h;inttypes.h;langinfo.h;limits.h;linux/types.h;linux/fiemap.h;linux/fs.h;linux/magic.h;locale.h;memory.h;paths.h;poll.h;pwd.h;regex.h;signal.h;stdarg.h;stdint.h;stdlib.h;string.h;strings.h;sys/cdefs.h;sys/ioctl.h;sys/param.h;sys/poll.h;sys/select.h;sys/stat.h;sys/statfs.h;sys/statvfs.h;sys/time.h;sys/utsname.h;sys/vfs.h exist passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3549814726/fast"
make -f CMakeFiles/cmTryCompileExec3549814726.dir/build.make CMakeFiles/cmTryCompileExec3549814726.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3549814726.dir/CheckIncludeFiles.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec3549814726.dir/CheckIncludeFiles.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec3549814726
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3549814726.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec3549814726.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec3549814726 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if files sys/types.h;ctype.h;dlfcn.h;errno.h;fcntl.h;grp.h;inttypes.h;langinfo.h;limits.h;linux/types.h;linux/fiemap.h;linux/fs.h;linux/magic.h;locale.h;memory.h;paths.h;poll.h;pwd.h;regex.h;signal.h;stdarg.h;stdint.h;stdlib.h;string.h;strings.h;sys/cdefs.h;sys/ioctl.h;sys/param.h;sys/poll.h;sys/select.h;sys/stat.h;sys/statfs.h;sys/statvfs.h;sys/time.h;sys/utsname.h;sys/vfs.h;sys/wait.h exist passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec103630891/fast"
make -f CMakeFiles/cmTryCompileExec103630891.dir/build.make CMakeFiles/cmTryCompileExec103630891.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec103630891.dir/CheckIncludeFiles.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec103630891.dir/CheckIncludeFiles.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec103630891
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec103630891.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec103630891.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec103630891 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if files sys/types.h;ctype.h;dlfcn.h;errno.h;fcntl.h;grp.h;inttypes.h;langinfo.h;limits.h;linux/types.h;linux/fiemap.h;linux/fs.h;linux/magic.h;locale.h;memory.h;paths.h;poll.h;pwd.h;regex.h;signal.h;stdarg.h;stdint.h;stdlib.h;string.h;strings.h;sys/cdefs.h;sys/ioctl.h;sys/param.h;sys/poll.h;sys/select.h;sys/stat.h;sys/statfs.h;sys/statvfs.h;sys/time.h;sys/utsname.h;sys/vfs.h;sys/wait.h;time.h;unistd.h;utime.h;wchar.h exist passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1216179889/fast"
make -f CMakeFiles/cmTryCompileExec1216179889.dir/build.make CMakeFiles/cmTryCompileExec1216179889.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1216179889.dir/CheckIncludeFiles.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec1216179889.dir/CheckIncludeFiles.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec1216179889
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1216179889.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec1216179889.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec1216179889 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if files sys/types.h;ctype.h;dlfcn.h;errno.h;fcntl.h;grp.h;inttypes.h;langinfo.h;limits.h;linux/types.h;linux/fiemap.h;linux/fs.h;linux/magic.h;locale.h;memory.h;paths.h;poll.h;pwd.h;regex.h;signal.h;stdarg.h;stdint.h;stdlib.h;string.h;strings.h;sys/cdefs.h;sys/ioctl.h;sys/param.h;sys/poll.h;sys/select.h;sys/stat.h;sys/statfs.h;sys/statvfs.h;sys/time.h;sys/utsname.h;sys/vfs.h;sys/wait.h;time.h;unistd.h;utime.h;wchar.h;wctype.h exist passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec344627899/fast"
make -f CMakeFiles/cmTryCompileExec344627899.dir/build.make CMakeFiles/cmTryCompileExec344627899.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec344627899.dir/CheckIncludeFiles.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec344627899.dir/CheckIncludeFiles.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec344627899
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec344627899.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec344627899.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec344627899 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Performing C SOURCE FILE Test SAFE_TO_DEFINE_EXTENSIONS succeded with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1702985102/fast"
make -f CMakeFiles/cmTryCompileExec1702985102.dir/build.make CMakeFiles/cmTryCompileExec1702985102.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1702985102.dir/src.c.o
/usr/bin/gcc   -w  -DSAFE_TO_DEFINE_EXTENSIONS   -o CMakeFiles/cmTryCompileExec1702985102.dir/src.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/src.c
Linking C executable cmTryCompileExec1702985102
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1702985102.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DSAFE_TO_DEFINE_EXTENSIONS    CMakeFiles/cmTryCompileExec1702985102.dir/src.c.o  -o cmTryCompileExec1702985102 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'

Source file was:
#define __EXTENSIONS__ 1
   
   int main() { return 0;}
Determining if the function chown exists passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1687944860/fast"
make -f CMakeFiles/cmTryCompileExec1687944860.dir/build.make CMakeFiles/cmTryCompileExec1687944860.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1687944860.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=chown  -fno-builtin   -o CMakeFiles/cmTryCompileExec1687944860.dir/CheckFunctionExists.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec1687944860
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1687944860.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=chown  -fno-builtin    CMakeFiles/cmTryCompileExec1687944860.dir/CheckFunctionExists.c.o  -o cmTryCompileExec1687944860 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if the function chroot exists passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec252632745/fast"
make -f CMakeFiles/cmTryCompileExec252632745.dir/build.make CMakeFiles/cmTryCompileExec252632745.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec252632745.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=chroot  -fno-builtin   -o CMakeFiles/cmTryCompileExec252632745.dir/CheckFunctionExists.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec252632745
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec252632745.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=chroot  -fno-builtin    CMakeFiles/cmTryCompileExec252632745.dir/CheckFunctionExists.c.o  -o cmTryCompileExec252632745 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if the function ctime_r exists passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2649889514/fast"
make -f CMakeFiles/cmTryCompileExec2649889514.dir/build.make CMakeFiles/cmTryCompileExec2649889514.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2649889514.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=ctime_r  -fno-builtin   -o CMakeFiles/cmTryCompileExec2649889514.dir/CheckFunctionExists.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec2649889514
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2649889514.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=ctime_r  -fno-builtin    CMakeFiles/cmTryCompileExec2649889514.dir/CheckFunctionExists.c.o  -o cmTryCompileExec2649889514 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if the function fchdir exists passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2883344005/fast"
make -f CMakeFiles/cmTryCompileExec2883344005.dir/build.make CMakeFiles/cmTryCompileExec2883344005.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2883344005.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=fchdir  -fno-builtin   -o CMakeFiles/cmTryCompileExec2883344005.dir/CheckFunctionExists.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec2883344005
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2883344005.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=fchdir  -fno-builtin    CMakeFiles/cmTryCompileExec2883344005.dir/CheckFunctionExists.c.o  -o cmTryCompileExec2883344005 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if the function fchmod exists passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2666076848/fast"
make -f CMakeFiles/cmTryCompileExec2666076848.dir/build.make CMakeFiles/cmTryCompileExec2666076848.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2666076848.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=fchmod  -fno-builtin   -o CMakeFiles/cmTryCompileExec2666076848.dir/CheckFunctionExists.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec2666076848
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2666076848.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=fchmod  -fno-builtin    CMakeFiles/cmTryCompileExec2666076848.dir/CheckFunctionExists.c.o  -o cmTryCompileExec2666076848 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if the function fchown exists passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2686857356/fast"
make -f CMakeFiles/cmTryCompileExec2686857356.dir/build.make CMakeFiles/cmTryCompileExec2686857356.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2686857356.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=fchown  -fno-builtin   -o CMakeFiles/cmTryCompileExec2686857356.dir/CheckFunctionExists.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec2686857356
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2686857356.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=fchown  -fno-builtin    CMakeFiles/cmTryCompileExec2686857356.dir/CheckFunctionExists.c.o  -o cmTryCompileExec2686857356 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if the function fcntl exists passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec562440039/fast"
make -f CMakeFiles/cmTryCompileExec562440039.dir/build.make CMakeFiles/cmTryCompileExec562440039.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec562440039.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=fcntl  -fno-builtin   -o CMakeFiles/cmTryCompileExec562440039.dir/CheckFunctionExists.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec562440039
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec562440039.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=fcntl  -fno-builtin    CMakeFiles/cmTryCompileExec562440039.dir/CheckFunctionExists.c.o  -o cmTryCompileExec562440039 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if the function fdopendir exists passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3557061593/fast"
make -f CMakeFiles/cmTryCompileExec3557061593.dir/build.make CMakeFiles/cmTryCompileExec3557061593.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3557061593.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=fdopendir  -fno-builtin   -o CMakeFiles/cmTryCompileExec3557061593.dir/CheckFunctionExists.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec3557061593
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3557061593.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=fdopendir  -fno-builtin    CMakeFiles/cmTryCompileExec3557061593.dir/CheckFunctionExists.c.o  -o cmTryCompileExec3557061593 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if the function fstat exists passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1534719721/fast"
make -f CMakeFiles/cmTryCompileExec1534719721.dir/build.make CMakeFiles/cmTryCompileExec1534719721.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1534719721.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=fstat  -fno-builtin   -o CMakeFiles/cmTryCompileExec1534719721.dir/CheckFunctionExists.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec1534719721
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1534719721.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=fstat  -fno-builtin    CMakeFiles/cmTryCompileExec1534719721.dir/CheckFunctionExists.c.o  -o cmTryCompileExec1534719721 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if the function fstatat exists passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec489885766/fast"
make -f CMakeFiles/cmTryCompileExec489885766.dir/build.make CMakeFiles/cmTryCompileExec489885766.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec489885766.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=fstatat  -fno-builtin   -o CMakeFiles/cmTryCompileExec489885766.dir/CheckFunctionExists.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec489885766
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec489885766.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=fstatat  -fno-builtin    CMakeFiles/cmTryCompileExec489885766.dir/CheckFunctionExists.c.o  -o cmTryCompileExec489885766 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if the function fstatfs exists passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1524479045/fast"
make -f CMakeFiles/cmTryCompileExec1524479045.dir/build.make CMakeFiles/cmTryCompileExec1524479045.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1524479045.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=fstatfs  -fno-builtin   -o CMakeFiles/cmTryCompileExec1524479045.dir/CheckFunctionExists.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec1524479045
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1524479045.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=fstatfs  -fno-builtin    CMakeFiles/cmTryCompileExec1524479045.dir/CheckFunctionExists.c.o  -o cmTryCompileExec1524479045 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if the function fstatvfs exists passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1340027599/fast"
make -f CMakeFiles/cmTryCompileExec1340027599.dir/build.make CMakeFiles/cmTryCompileExec1340027599.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1340027599.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=fstatvfs  -fno-builtin   -o CMakeFiles/cmTryCompileExec1340027599.dir/CheckFunctionExists.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec1340027599
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1340027599.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=fstatvfs  -fno-builtin    CMakeFiles/cmTryCompileExec1340027599.dir/CheckFunctionExists.c.o  -o cmTryCompileExec1340027599 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if the function futimens exists passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec377126156/fast"
make -f CMakeFiles/cmTryCompileExec377126156.dir/build.make CMakeFiles/cmTryCompileExec377126156.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec377126156.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=futimens  -fno-builtin   -o CMakeFiles/cmTryCompileExec377126156.dir/CheckFunctionExists.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec377126156
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec377126156.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=futimens  -fno-builtin    CMakeFiles/cmTryCompileExec377126156.dir/CheckFunctionExists.c.o  -o cmTryCompileExec377126156 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if the function futimes exists passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec766709451/fast"
make -f CMakeFiles/cmTryCompileExec766709451.dir/build.make CMakeFiles/cmTryCompileExec766709451.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec766709451.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=futimes  -fno-builtin   -o CMakeFiles/cmTryCompileExec766709451.dir/CheckFunctionExists.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec766709451
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec766709451.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=futimes  -fno-builtin    CMakeFiles/cmTryCompileExec766709451.dir/CheckFunctionExists.c.o  -o cmTryCompileExec766709451 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if the function futimesat exists passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3769554715/fast"
make -f CMakeFiles/cmTryCompileExec3769554715.dir/build.make CMakeFiles/cmTryCompileExec3769554715.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3769554715.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=futimesat  -fno-builtin   -o CMakeFiles/cmTryCompileExec3769554715.dir/CheckFunctionExists.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec3769554715
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3769554715.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=futimesat  -fno-builtin    CMakeFiles/cmTryCompileExec3769554715.dir/CheckFunctionExists.c.o  -o cmTryCompileExec3769554715 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if the function getgrgid_r exists passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec627703919/fast"
make -f CMakeFiles/cmTryCompileExec627703919.dir/build.make CMakeFiles/cmTryCompileExec627703919.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec627703919.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=getgrgid_r  -fno-builtin   -o CMakeFiles/cmTryCompileExec627703919.dir/CheckFunctionExists.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec627703919
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec627703919.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=getgrgid_r  -fno-builtin    CMakeFiles/cmTryCompileExec627703919.dir/CheckFunctionExists.c.o  -o cmTryCompileExec627703919 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if the function getgrnam_r exists passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec4049277411/fast"
make -f CMakeFiles/cmTryCompileExec4049277411.dir/build.make CMakeFiles/cmTryCompileExec4049277411.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec4049277411.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=getgrnam_r  -fno-builtin   -o CMakeFiles/cmTryCompileExec4049277411.dir/CheckFunctionExists.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec4049277411
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec4049277411.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=getgrnam_r  -fno-builtin    CMakeFiles/cmTryCompileExec4049277411.dir/CheckFunctionExists.c.o  -o cmTryCompileExec4049277411 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if the function getpwnam_r exists passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2348086709/fast"
make -f CMakeFiles/cmTryCompileExec2348086709.dir/build.make CMakeFiles/cmTryCompileExec2348086709.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2348086709.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=getpwnam_r  -fno-builtin   -o CMakeFiles/cmTryCompileExec2348086709.dir/CheckFunctionExists.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec2348086709
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2348086709.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=getpwnam_r  -fno-builtin    CMakeFiles/cmTryCompileExec2348086709.dir/CheckFunctionExists.c.o  -o cmTryCompileExec2348086709 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if the function getpwuid_r exists passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec57755702/fast"
make -f CMakeFiles/cmTryCompileExec57755702.dir/build.make CMakeFiles/cmTryCompileExec57755702.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec57755702.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=getpwuid_r  -fno-builtin   -o CMakeFiles/cmTryCompileExec57755702.dir/CheckFunctionExists.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec57755702
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec57755702.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=getpwuid_r  -fno-builtin    CMakeFiles/cmTryCompileExec57755702.dir/CheckFunctionExists.c.o  -o cmTryCompileExec57755702 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if the function getpid exists passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3273960188/fast"
make -f CMakeFiles/cmTryCompileExec3273960188.dir/build.make CMakeFiles/cmTryCompileExec3273960188.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3273960188.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=getpid  -fno-builtin   -o CMakeFiles/cmTryCompileExec3273960188.dir/CheckFunctionExists.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec3273960188
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3273960188.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=getpid  -fno-builtin    CMakeFiles/cmTryCompileExec3273960188.dir/CheckFunctionExists.c.o  -o cmTryCompileExec3273960188 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if the function lchown exists passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1808065134/fast"
make -f CMakeFiles/cmTryCompileExec1808065134.dir/build.make CMakeFiles/cmTryCompileExec1808065134.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1808065134.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=lchown  -fno-builtin   -o CMakeFiles/cmTryCompileExec1808065134.dir/CheckFunctionExists.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec1808065134
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1808065134.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=lchown  -fno-builtin    CMakeFiles/cmTryCompileExec1808065134.dir/CheckFunctionExists.c.o  -o cmTryCompileExec1808065134 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if the function link exists passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2476127377/fast"
make -f CMakeFiles/cmTryCompileExec2476127377.dir/build.make CMakeFiles/cmTryCompileExec2476127377.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2476127377.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=link  -fno-builtin   -o CMakeFiles/cmTryCompileExec2476127377.dir/CheckFunctionExists.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec2476127377
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2476127377.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=link  -fno-builtin    CMakeFiles/cmTryCompileExec2476127377.dir/CheckFunctionExists.c.o  -o cmTryCompileExec2476127377 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if the function lstat exists passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2516995236/fast"
make -f CMakeFiles/cmTryCompileExec2516995236.dir/build.make CMakeFiles/cmTryCompileExec2516995236.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2516995236.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=lstat  -fno-builtin   -o CMakeFiles/cmTryCompileExec2516995236.dir/CheckFunctionExists.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec2516995236
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2516995236.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=lstat  -fno-builtin    CMakeFiles/cmTryCompileExec2516995236.dir/CheckFunctionExists.c.o  -o cmTryCompileExec2516995236 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if the function lutimes exists passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec944437293/fast"
make -f CMakeFiles/cmTryCompileExec944437293.dir/build.make CMakeFiles/cmTryCompileExec944437293.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec944437293.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=lutimes  -fno-builtin   -o CMakeFiles/cmTryCompileExec944437293.dir/CheckFunctionExists.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec944437293
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec944437293.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=lutimes  -fno-builtin    CMakeFiles/cmTryCompileExec944437293.dir/CheckFunctionExists.c.o  -o cmTryCompileExec944437293 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if the function mbrtowc exists passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2229968085/fast"
make -f CMakeFiles/cmTryCompileExec2229968085.dir/build.make CMakeFiles/cmTryCompileExec2229968085.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2229968085.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=mbrtowc  -fno-builtin   -o CMakeFiles/cmTryCompileExec2229968085.dir/CheckFunctionExists.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec2229968085
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2229968085.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=mbrtowc  -fno-builtin    CMakeFiles/cmTryCompileExec2229968085.dir/CheckFunctionExists.c.o  -o cmTryCompileExec2229968085 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if the function mbsnrtowcs exists passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3421018478/fast"
make -f CMakeFiles/cmTryCompileExec3421018478.dir/build.make CMakeFiles/cmTryCompileExec3421018478.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3421018478.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=mbsnrtowcs  -fno-builtin   -o CMakeFiles/cmTryCompileExec3421018478.dir/CheckFunctionExists.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec3421018478
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3421018478.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=mbsnrtowcs  -fno-builtin    CMakeFiles/cmTryCompileExec3421018478.dir/CheckFunctionExists.c.o  -o cmTryCompileExec3421018478 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if the function memmove exists passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec4218111280/fast"
make -f CMakeFiles/cmTryCompileExec4218111280.dir/build.make CMakeFiles/cmTryCompileExec4218111280.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec4218111280.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=memmove  -fno-builtin   -o CMakeFiles/cmTryCompileExec4218111280.dir/CheckFunctionExists.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec4218111280
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec4218111280.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=memmove  -fno-builtin    CMakeFiles/cmTryCompileExec4218111280.dir/CheckFunctionExists.c.o  -o cmTryCompileExec4218111280 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if the function mkdir exists passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3323866465/fast"
make -f CMakeFiles/cmTryCompileExec3323866465.dir/build.make CMakeFiles/cmTryCompileExec3323866465.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3323866465.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=mkdir  -fno-builtin   -o CMakeFiles/cmTryCompileExec3323866465.dir/CheckFunctionExists.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec3323866465
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3323866465.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=mkdir  -fno-builtin    CMakeFiles/cmTryCompileExec3323866465.dir/CheckFunctionExists.c.o  -o cmTryCompileExec3323866465 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if the function mkfifo exists passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec986056351/fast"
make -f CMakeFiles/cmTryCompileExec986056351.dir/build.make CMakeFiles/cmTryCompileExec986056351.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec986056351.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=mkfifo  -fno-builtin   -o CMakeFiles/cmTryCompileExec986056351.dir/CheckFunctionExists.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec986056351
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec986056351.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=mkfifo  -fno-builtin    CMakeFiles/cmTryCompileExec986056351.dir/CheckFunctionExists.c.o  -o cmTryCompileExec986056351 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if the function mknod exists passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec847308364/fast"
make -f CMakeFiles/cmTryCompileExec847308364.dir/build.make CMakeFiles/cmTryCompileExec847308364.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec847308364.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=mknod  -fno-builtin   -o CMakeFiles/cmTryCompileExec847308364.dir/CheckFunctionExists.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec847308364
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec847308364.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=mknod  -fno-builtin    CMakeFiles/cmTryCompileExec847308364.dir/CheckFunctionExists.c.o  -o cmTryCompileExec847308364 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if the function mkstemp exists passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1341117123/fast"
make -f CMakeFiles/cmTryCompileExec1341117123.dir/build.make CMakeFiles/cmTryCompileExec1341117123.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1341117123.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=mkstemp  -fno-builtin   -o CMakeFiles/cmTryCompileExec1341117123.dir/CheckFunctionExists.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec1341117123
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1341117123.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=mkstemp  -fno-builtin    CMakeFiles/cmTryCompileExec1341117123.dir/CheckFunctionExists.c.o  -o cmTryCompileExec1341117123 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if the function nl_langinfo exists passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1888957694/fast"
make -f CMakeFiles/cmTryCompileExec1888957694.dir/build.make CMakeFiles/cmTryCompileExec1888957694.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1888957694.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=nl_langinfo  -fno-builtin   -o CMakeFiles/cmTryCompileExec1888957694.dir/CheckFunctionExists.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec1888957694
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1888957694.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=nl_langinfo  -fno-builtin    CMakeFiles/cmTryCompileExec1888957694.dir/CheckFunctionExists.c.o  -o cmTryCompileExec1888957694 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if the function openat exists passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1905556214/fast"
make -f CMakeFiles/cmTryCompileExec1905556214.dir/build.make CMakeFiles/cmTryCompileExec1905556214.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1905556214.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=openat  -fno-builtin   -o CMakeFiles/cmTryCompileExec1905556214.dir/CheckFunctionExists.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec1905556214
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1905556214.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=openat  -fno-builtin    CMakeFiles/cmTryCompileExec1905556214.dir/CheckFunctionExists.c.o  -o cmTryCompileExec1905556214 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if the function readlink exists passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec4135008511/fast"
make -f CMakeFiles/cmTryCompileExec4135008511.dir/build.make CMakeFiles/cmTryCompileExec4135008511.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec4135008511.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=readlink  -fno-builtin   -o CMakeFiles/cmTryCompileExec4135008511.dir/CheckFunctionExists.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec4135008511
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec4135008511.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=readlink  -fno-builtin    CMakeFiles/cmTryCompileExec4135008511.dir/CheckFunctionExists.c.o  -o cmTryCompileExec4135008511 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if the function setenv exists passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2860529419/fast"
make -f CMakeFiles/cmTryCompileExec2860529419.dir/build.make CMakeFiles/cmTryCompileExec2860529419.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2860529419.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=setenv  -fno-builtin   -o CMakeFiles/cmTryCompileExec2860529419.dir/CheckFunctionExists.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec2860529419
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2860529419.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=setenv  -fno-builtin    CMakeFiles/cmTryCompileExec2860529419.dir/CheckFunctionExists.c.o  -o cmTryCompileExec2860529419 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if the function statfs exists passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3624406516/fast"
make -f CMakeFiles/cmTryCompileExec3624406516.dir/build.make CMakeFiles/cmTryCompileExec3624406516.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3624406516.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=statfs  -fno-builtin   -o CMakeFiles/cmTryCompileExec3624406516.dir/CheckFunctionExists.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec3624406516
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3624406516.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=statfs  -fno-builtin    CMakeFiles/cmTryCompileExec3624406516.dir/CheckFunctionExists.c.o  -o cmTryCompileExec3624406516 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if the function statvfs exists passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec91432993/fast"
make -f CMakeFiles/cmTryCompileExec91432993.dir/build.make CMakeFiles/cmTryCompileExec91432993.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec91432993.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=statvfs  -fno-builtin   -o CMakeFiles/cmTryCompileExec91432993.dir/CheckFunctionExists.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec91432993
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec91432993.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=statvfs  -fno-builtin    CMakeFiles/cmTryCompileExec91432993.dir/CheckFunctionExists.c.o  -o cmTryCompileExec91432993 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if the function strchr exists passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3807199970/fast"
make -f CMakeFiles/cmTryCompileExec3807199970.dir/build.make CMakeFiles/cmTryCompileExec3807199970.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3807199970.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=strchr  -fno-builtin   -o CMakeFiles/cmTryCompileExec3807199970.dir/CheckFunctionExists.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec3807199970
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3807199970.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=strchr  -fno-builtin    CMakeFiles/cmTryCompileExec3807199970.dir/CheckFunctionExists.c.o  -o cmTryCompileExec3807199970 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if the function strerror exists passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1965164595/fast"
make -f CMakeFiles/cmTryCompileExec1965164595.dir/build.make CMakeFiles/cmTryCompileExec1965164595.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1965164595.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=strerror  -fno-builtin   -o CMakeFiles/cmTryCompileExec1965164595.dir/CheckFunctionExists.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec1965164595
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1965164595.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=strerror  -fno-builtin    CMakeFiles/cmTryCompileExec1965164595.dir/CheckFunctionExists.c.o  -o cmTryCompileExec1965164595 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if the function strrchr exists passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec364145944/fast"
make -f CMakeFiles/cmTryCompileExec364145944.dir/build.make CMakeFiles/cmTryCompileExec364145944.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec364145944.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=strrchr  -fno-builtin   -o CMakeFiles/cmTryCompileExec364145944.dir/CheckFunctionExists.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec364145944
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec364145944.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=strrchr  -fno-builtin    CMakeFiles/cmTryCompileExec364145944.dir/CheckFunctionExists.c.o  -o cmTryCompileExec364145944 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if the function symlink exists passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2285965194/fast"
make -f CMakeFiles/cmTryCompileExec2285965194.dir/build.make CMakeFiles/cmTryCompileExec2285965194.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2285965194.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=symlink  -fno-builtin   -o CMakeFiles/cmTryCompileExec2285965194.dir/CheckFunctionExists.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec2285965194
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2285965194.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=symlink  -fno-builtin    CMakeFiles/cmTryCompileExec2285965194.dir/CheckFunctionExists.c.o  -o cmTryCompileExec2285965194 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if the function timegm exists passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2230437093/fast"
make -f CMakeFiles/cmTryCompileExec2230437093.dir/build.make CMakeFiles/cmTryCompileExec2230437093.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2230437093.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=timegm  -fno-builtin   -o CMakeFiles/cmTryCompileExec2230437093.dir/CheckFunctionExists.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec2230437093
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2230437093.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=timegm  -fno-builtin    CMakeFiles/cmTryCompileExec2230437093.dir/CheckFunctionExists.c.o  -o cmTryCompileExec2230437093 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if the function tzset exists passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1282762196/fast"
make -f CMakeFiles/cmTryCompileExec1282762196.dir/build.make CMakeFiles/cmTryCompileExec1282762196.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1282762196.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=tzset  -fno-builtin   -o CMakeFiles/cmTryCompileExec1282762196.dir/CheckFunctionExists.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec1282762196
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1282762196.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=tzset  -fno-builtin    CMakeFiles/cmTryCompileExec1282762196.dir/CheckFunctionExists.c.o  -o cmTryCompileExec1282762196 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if the function utimes exists passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3982436295/fast"
make -f CMakeFiles/cmTryCompileExec3982436295.dir/build.make CMakeFiles/cmTryCompileExec3982436295.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3982436295.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=utimes  -fno-builtin   -o CMakeFiles/cmTryCompileExec3982436295.dir/CheckFunctionExists.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec3982436295
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3982436295.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=utimes  -fno-builtin    CMakeFiles/cmTryCompileExec3982436295.dir/CheckFunctionExists.c.o  -o cmTryCompileExec3982436295 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if the function utimensat exists passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2655848212/fast"
make -f CMakeFiles/cmTryCompileExec2655848212.dir/build.make CMakeFiles/cmTryCompileExec2655848212.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2655848212.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=utimensat  -fno-builtin   -o CMakeFiles/cmTryCompileExec2655848212.dir/CheckFunctionExists.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec2655848212
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2655848212.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=utimensat  -fno-builtin    CMakeFiles/cmTryCompileExec2655848212.dir/CheckFunctionExists.c.o  -o cmTryCompileExec2655848212 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if the function vfork exists passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2374731212/fast"
make -f CMakeFiles/cmTryCompileExec2374731212.dir/build.make CMakeFiles/cmTryCompileExec2374731212.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2374731212.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=vfork  -fno-builtin   -o CMakeFiles/cmTryCompileExec2374731212.dir/CheckFunctionExists.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec2374731212
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2374731212.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=vfork  -fno-builtin    CMakeFiles/cmTryCompileExec2374731212.dir/CheckFunctionExists.c.o  -o cmTryCompileExec2374731212 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if the function wcrtomb exists passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec589389589/fast"
make -f CMakeFiles/cmTryCompileExec589389589.dir/build.make CMakeFiles/cmTryCompileExec589389589.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec589389589.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=wcrtomb  -fno-builtin   -o CMakeFiles/cmTryCompileExec589389589.dir/CheckFunctionExists.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec589389589
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec589389589.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=wcrtomb  -fno-builtin    CMakeFiles/cmTryCompileExec589389589.dir/CheckFunctionExists.c.o  -o cmTryCompileExec589389589 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if the function wcscmp exists passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2368282834/fast"
make -f CMakeFiles/cmTryCompileExec2368282834.dir/build.make CMakeFiles/cmTryCompileExec2368282834.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2368282834.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=wcscmp  -fno-builtin   -o CMakeFiles/cmTryCompileExec2368282834.dir/CheckFunctionExists.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec2368282834
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2368282834.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=wcscmp  -fno-builtin    CMakeFiles/cmTryCompileExec2368282834.dir/CheckFunctionExists.c.o  -o cmTryCompileExec2368282834 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if the function wcscpy exists passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3877731899/fast"
make -f CMakeFiles/cmTryCompileExec3877731899.dir/build.make CMakeFiles/cmTryCompileExec3877731899.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3877731899.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=wcscpy  -fno-builtin   -o CMakeFiles/cmTryCompileExec3877731899.dir/CheckFunctionExists.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec3877731899
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3877731899.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=wcscpy  -fno-builtin    CMakeFiles/cmTryCompileExec3877731899.dir/CheckFunctionExists.c.o  -o cmTryCompileExec3877731899 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if the function wcslen exists passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3638685880/fast"
make -f CMakeFiles/cmTryCompileExec3638685880.dir/build.make CMakeFiles/cmTryCompileExec3638685880.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3638685880.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=wcslen  -fno-builtin   -o CMakeFiles/cmTryCompileExec3638685880.dir/CheckFunctionExists.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec3638685880
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3638685880.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=wcslen  -fno-builtin    CMakeFiles/cmTryCompileExec3638685880.dir/CheckFunctionExists.c.o  -o cmTryCompileExec3638685880 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if the function wcsnrtombs exists passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2447233398/fast"
make -f CMakeFiles/cmTryCompileExec2447233398.dir/build.make CMakeFiles/cmTryCompileExec2447233398.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2447233398.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=wcsnrtombs  -fno-builtin   -o CMakeFiles/cmTryCompileExec2447233398.dir/CheckFunctionExists.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec2447233398
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2447233398.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=wcsnrtombs  -fno-builtin    CMakeFiles/cmTryCompileExec2447233398.dir/CheckFunctionExists.c.o  -o cmTryCompileExec2447233398 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if the function wctomb exists passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2580280537/fast"
make -f CMakeFiles/cmTryCompileExec2580280537.dir/build.make CMakeFiles/cmTryCompileExec2580280537.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2580280537.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=wctomb  -fno-builtin   -o CMakeFiles/cmTryCompileExec2580280537.dir/CheckFunctionExists.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec2580280537
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2580280537.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=wctomb  -fno-builtin    CMakeFiles/cmTryCompileExec2580280537.dir/CheckFunctionExists.c.o  -o cmTryCompileExec2580280537 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if the function fseeko exists passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3288432761/fast"
make -f CMakeFiles/cmTryCompileExec3288432761.dir/build.make CMakeFiles/cmTryCompileExec3288432761.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3288432761.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=fseeko  -fno-builtin   -o CMakeFiles/cmTryCompileExec3288432761.dir/CheckFunctionExists.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec3288432761
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3288432761.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=fseeko  -fno-builtin    CMakeFiles/cmTryCompileExec3288432761.dir/CheckFunctionExists.c.o  -o cmTryCompileExec3288432761 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if the function vprintf exists passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3448514908/fast"
make -f CMakeFiles/cmTryCompileExec3448514908.dir/build.make CMakeFiles/cmTryCompileExec3448514908.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3448514908.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=vprintf  -fno-builtin   -o CMakeFiles/cmTryCompileExec3448514908.dir/CheckFunctionExists.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec3448514908
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3448514908.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=vprintf  -fno-builtin    CMakeFiles/cmTryCompileExec3448514908.dir/CheckFunctionExists.c.o  -o cmTryCompileExec3448514908 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if the function wmemcmp exists passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3444216652/fast"
make -f CMakeFiles/cmTryCompileExec3444216652.dir/build.make CMakeFiles/cmTryCompileExec3444216652.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3444216652.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=wmemcmp  -fno-builtin   -o CMakeFiles/cmTryCompileExec3444216652.dir/CheckFunctionExists.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec3444216652
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3444216652.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=wmemcmp  -fno-builtin    CMakeFiles/cmTryCompileExec3444216652.dir/CheckFunctionExists.c.o  -o cmTryCompileExec3444216652 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if the function wmemcpy exists passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2767452569/fast"
make -f CMakeFiles/cmTryCompileExec2767452569.dir/build.make CMakeFiles/cmTryCompileExec2767452569.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2767452569.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=wmemcpy  -fno-builtin   -o CMakeFiles/cmTryCompileExec2767452569.dir/CheckFunctionExists.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec2767452569
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2767452569.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=wmemcpy  -fno-builtin    CMakeFiles/cmTryCompileExec2767452569.dir/CheckFunctionExists.c.o  -o cmTryCompileExec2767452569 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Performing C SOURCE FILE Test HAVE_READDIR_R succeded with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3246008051/fast"
make -f CMakeFiles/cmTryCompileExec3246008051.dir/build.make CMakeFiles/cmTryCompileExec3246008051.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3246008051.dir/src.c.o
/usr/bin/gcc   -w  -DHAVE_READDIR_R   -o CMakeFiles/cmTryCompileExec3246008051.dir/src.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/src.c
Linking C executable cmTryCompileExec3246008051
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3246008051.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DHAVE_READDIR_R    CMakeFiles/cmTryCompileExec3246008051.dir/src.c.o  -o cmTryCompileExec3246008051 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'

Source file was:
#include <dirent.h>
int main() {DIR *d = opendir("."); struct dirent e,*r; return readdir_r(d,&e,&r);}
Performing C SOURCE FILE Test HAVE_READLINKAT succeded with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2638750324/fast"
make -f CMakeFiles/cmTryCompileExec2638750324.dir/build.make CMakeFiles/cmTryCompileExec2638750324.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2638750324.dir/src.c.o
/usr/bin/gcc   -w  -DHAVE_READLINKAT   -o CMakeFiles/cmTryCompileExec2638750324.dir/src.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/src.c
Linking C executable cmTryCompileExec2638750324
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2638750324.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DHAVE_READLINKAT    CMakeFiles/cmTryCompileExec2638750324.dir/src.c.o  -o cmTryCompileExec2638750324 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'

Source file was:
#include <fcntl.h>
#include <unistd.h>
int main() {char buf[10]; return readlinkat(AT_FDCWD, "", buf, 0);}
Performing C SOURCE FILE Test MAJOR_IN_SYSMACROS succeded with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3182094905/fast"
make -f CMakeFiles/cmTryCompileExec3182094905.dir/build.make CMakeFiles/cmTryCompileExec3182094905.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3182094905.dir/src.c.o
/usr/bin/gcc   -w  -DMAJOR_IN_SYSMACROS   -o CMakeFiles/cmTryCompileExec3182094905.dir/src.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/src.c
Linking C executable cmTryCompileExec3182094905
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3182094905.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DMAJOR_IN_SYSMACROS    CMakeFiles/cmTryCompileExec3182094905.dir/src.c.o  -o cmTryCompileExec3182094905 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'

Source file was:
#include <sys/sysmacros.h>
int main() { return major(256); }
Determining if the EILSEQ exist passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2352450683/fast"
make -f CMakeFiles/cmTryCompileExec2352450683.dir/build.make CMakeFiles/cmTryCompileExec2352450683.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2352450683.dir/CheckSymbolExists.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec2352450683.dir/CheckSymbolExists.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec2352450683
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2352450683.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec2352450683.dir/CheckSymbolExists.c.o  -o cmTryCompileExec2352450683 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'

File /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <errno.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef EILSEQ
  return ((int*)(&EILSEQ))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the INT64_MAX exist passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec4278886416/fast"
make -f CMakeFiles/cmTryCompileExec4278886416.dir/build.make CMakeFiles/cmTryCompileExec4278886416.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec4278886416.dir/CheckSymbolExists.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec4278886416.dir/CheckSymbolExists.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec4278886416
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec4278886416.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec4278886416.dir/CheckSymbolExists.c.o  -o cmTryCompileExec4278886416 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'

File /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <limits.h>
#include <stdint.h>
#include <inttypes.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef INT64_MAX
  return ((int*)(&INT64_MAX))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the INT64_MIN exist passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3533870958/fast"
make -f CMakeFiles/cmTryCompileExec3533870958.dir/build.make CMakeFiles/cmTryCompileExec3533870958.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3533870958.dir/CheckSymbolExists.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec3533870958.dir/CheckSymbolExists.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec3533870958
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3533870958.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec3533870958.dir/CheckSymbolExists.c.o  -o cmTryCompileExec3533870958 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'

File /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <limits.h>
#include <stdint.h>
#include <inttypes.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef INT64_MIN
  return ((int*)(&INT64_MIN))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the UINT32_MAX exist passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec770557995/fast"
make -f CMakeFiles/cmTryCompileExec770557995.dir/build.make CMakeFiles/cmTryCompileExec770557995.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec770557995.dir/CheckSymbolExists.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec770557995.dir/CheckSymbolExists.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec770557995
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec770557995.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec770557995.dir/CheckSymbolExists.c.o  -o cmTryCompileExec770557995 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'

File /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <limits.h>
#include <stdint.h>
#include <inttypes.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef UINT32_MAX
  return ((int*)(&UINT32_MAX))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the UINT64_MAX exist passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3929654372/fast"
make -f CMakeFiles/cmTryCompileExec3929654372.dir/build.make CMakeFiles/cmTryCompileExec3929654372.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3929654372.dir/CheckSymbolExists.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec3929654372.dir/CheckSymbolExists.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec3929654372
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3929654372.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec3929654372.dir/CheckSymbolExists.c.o  -o cmTryCompileExec3929654372 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'

File /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <limits.h>
#include <stdint.h>
#include <inttypes.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef UINT64_MAX
  return ((int*)(&UINT64_MAX))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the SIZE_MAX exist passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3388418627/fast"
make -f CMakeFiles/cmTryCompileExec3388418627.dir/build.make CMakeFiles/cmTryCompileExec3388418627.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3388418627.dir/CheckSymbolExists.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec3388418627.dir/CheckSymbolExists.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec3388418627
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3388418627.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec3388418627.dir/CheckSymbolExists.c.o  -o cmTryCompileExec3388418627 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'

File /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <limits.h>
#include <stdint.h>
#include <inttypes.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef SIZE_MAX
  return ((int*)(&SIZE_MAX))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the SSIZE_MAX exist passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1425262298/fast"
make -f CMakeFiles/cmTryCompileExec1425262298.dir/build.make CMakeFiles/cmTryCompileExec1425262298.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1425262298.dir/CheckSymbolExists.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec1425262298.dir/CheckSymbolExists.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec1425262298
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1425262298.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec1425262298.dir/CheckSymbolExists.c.o  -o cmTryCompileExec1425262298 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'

File /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <limits.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef SSIZE_MAX
  return ((int*)(&SSIZE_MAX))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Performing C SOURCE FILE Test HAVE_STRUCT_TM_TM_GMTOFF succeded with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3151967834/fast"
make -f CMakeFiles/cmTryCompileExec3151967834.dir/build.make CMakeFiles/cmTryCompileExec3151967834.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3151967834.dir/src.c.o
/usr/bin/gcc   -w  -DHAVE_STRUCT_TM_TM_GMTOFF   -o CMakeFiles/cmTryCompileExec3151967834.dir/src.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/src.c
Linking C executable cmTryCompileExec3151967834
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3151967834.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DHAVE_STRUCT_TM_TM_GMTOFF    CMakeFiles/cmTryCompileExec3151967834.dir/src.c.o  -o cmTryCompileExec3151967834 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'

Source file was:

#include <time.h>

int main()
{
   static struct tm tmp;
   if (sizeof(tmp.tm_gmtoff))
      return 0;
  return 0;
}

Performing C SOURCE FILE Test HAVE_STRUCT_STAT_ST_MTIM_TV_NSEC succeded with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3882486884/fast"
make -f CMakeFiles/cmTryCompileExec3882486884.dir/build.make CMakeFiles/cmTryCompileExec3882486884.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3882486884.dir/src.c.o
/usr/bin/gcc   -w  -DHAVE_STRUCT_STAT_ST_MTIM_TV_NSEC   -o CMakeFiles/cmTryCompileExec3882486884.dir/src.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/src.c
Linking C executable cmTryCompileExec3882486884
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3882486884.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DHAVE_STRUCT_STAT_ST_MTIM_TV_NSEC    CMakeFiles/cmTryCompileExec3882486884.dir/src.c.o  -o cmTryCompileExec3882486884 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'

Source file was:

#include <sys/types.h>
#include <sys/stat.h>

int main()
{
   static struct stat tmp;
   if (sizeof(tmp.st_mtim.tv_nsec))
      return 0;
  return 0;
}

Performing C SOURCE FILE Test HAVE_STRUCT_STAT_ST_BLKSIZE succeded with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1587683741/fast"
make -f CMakeFiles/cmTryCompileExec1587683741.dir/build.make CMakeFiles/cmTryCompileExec1587683741.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1587683741.dir/src.c.o
/usr/bin/gcc   -w  -DHAVE_STRUCT_STAT_ST_BLKSIZE   -o CMakeFiles/cmTryCompileExec1587683741.dir/src.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/src.c
Linking C executable cmTryCompileExec1587683741
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1587683741.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DHAVE_STRUCT_STAT_ST_BLKSIZE    CMakeFiles/cmTryCompileExec1587683741.dir/src.c.o  -o cmTryCompileExec1587683741 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'

Source file was:

#include <sys/types.h>
#include <sys/stat.h>

int main()
{
   static struct stat tmp;
   if (sizeof(tmp.st_blksize))
      return 0;
  return 0;
}

Determining size of short passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec541586033/fast"
make -f CMakeFiles/cmTryCompileExec541586033.dir/build.make CMakeFiles/cmTryCompileExec541586033.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec541586033.dir/SIZE_OF_SHORT.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec541586033.dir/SIZE_OF_SHORT.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CheckTypeSize/SIZE_OF_SHORT.c
Linking C executable cmTryCompileExec541586033
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec541586033.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec541586033.dir/SIZE_OF_SHORT.c.o  -o cmTryCompileExec541586033 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining size of int passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1084806499/fast"
make -f CMakeFiles/cmTryCompileExec1084806499.dir/build.make CMakeFiles/cmTryCompileExec1084806499.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1084806499.dir/SIZE_OF_INT.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec1084806499.dir/SIZE_OF_INT.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CheckTypeSize/SIZE_OF_INT.c
Linking C executable cmTryCompileExec1084806499
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1084806499.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec1084806499.dir/SIZE_OF_INT.c.o  -o cmTryCompileExec1084806499 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining size of long passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3548051931/fast"
make -f CMakeFiles/cmTryCompileExec3548051931.dir/build.make CMakeFiles/cmTryCompileExec3548051931.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3548051931.dir/SIZE_OF_LONG.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec3548051931.dir/SIZE_OF_LONG.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CheckTypeSize/SIZE_OF_LONG.c
Linking C executable cmTryCompileExec3548051931
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3548051931.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec3548051931.dir/SIZE_OF_LONG.c.o  -o cmTryCompileExec3548051931 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining size of long long passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec321260803/fast"
make -f CMakeFiles/cmTryCompileExec321260803.dir/build.make CMakeFiles/cmTryCompileExec321260803.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec321260803.dir/SIZE_OF_LONG_LONG.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec321260803.dir/SIZE_OF_LONG_LONG.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CheckTypeSize/SIZE_OF_LONG_LONG.c
Linking C executable cmTryCompileExec321260803
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec321260803.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec321260803.dir/SIZE_OF_LONG_LONG.c.o  -o cmTryCompileExec321260803 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining size of unsigned short passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3193500222/fast"
make -f CMakeFiles/cmTryCompileExec3193500222.dir/build.make CMakeFiles/cmTryCompileExec3193500222.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3193500222.dir/SIZE_OF_UNSIGNED_SHORT.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec3193500222.dir/SIZE_OF_UNSIGNED_SHORT.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CheckTypeSize/SIZE_OF_UNSIGNED_SHORT.c
Linking C executable cmTryCompileExec3193500222
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3193500222.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec3193500222.dir/SIZE_OF_UNSIGNED_SHORT.c.o  -o cmTryCompileExec3193500222 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining size of unsigned passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2363831850/fast"
make -f CMakeFiles/cmTryCompileExec2363831850.dir/build.make CMakeFiles/cmTryCompileExec2363831850.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2363831850.dir/SIZE_OF_UNSIGNED.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec2363831850.dir/SIZE_OF_UNSIGNED.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CheckTypeSize/SIZE_OF_UNSIGNED.c
Linking C executable cmTryCompileExec2363831850
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2363831850.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec2363831850.dir/SIZE_OF_UNSIGNED.c.o  -o cmTryCompileExec2363831850 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining size of unsigned long passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec180714736/fast"
make -f CMakeFiles/cmTryCompileExec180714736.dir/build.make CMakeFiles/cmTryCompileExec180714736.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec180714736.dir/SIZE_OF_UNSIGNED_LONG.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec180714736.dir/SIZE_OF_UNSIGNED_LONG.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CheckTypeSize/SIZE_OF_UNSIGNED_LONG.c
Linking C executable cmTryCompileExec180714736
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec180714736.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec180714736.dir/SIZE_OF_UNSIGNED_LONG.c.o  -o cmTryCompileExec180714736 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining size of unsigned long long passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2663157894/fast"
make -f CMakeFiles/cmTryCompileExec2663157894.dir/build.make CMakeFiles/cmTryCompileExec2663157894.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2663157894.dir/SIZE_OF_UNSIGNED_LONG_LONG.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec2663157894.dir/SIZE_OF_UNSIGNED_LONG_LONG.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CheckTypeSize/SIZE_OF_UNSIGNED_LONG_LONG.c
Linking C executable cmTryCompileExec2663157894
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2663157894.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec2663157894.dir/SIZE_OF_UNSIGNED_LONG_LONG.c.o  -o cmTryCompileExec2663157894 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining size of int16_t passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2137185987/fast"
make -f CMakeFiles/cmTryCompileExec2137185987.dir/build.make CMakeFiles/cmTryCompileExec2137185987.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2137185987.dir/INT16_T.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec2137185987.dir/INT16_T.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CheckTypeSize/INT16_T.c
Linking C executable cmTryCompileExec2137185987
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2137185987.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec2137185987.dir/INT16_T.c.o  -o cmTryCompileExec2137185987 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining size of int32_t passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3809821250/fast"
make -f CMakeFiles/cmTryCompileExec3809821250.dir/build.make CMakeFiles/cmTryCompileExec3809821250.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3809821250.dir/INT32_T.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec3809821250.dir/INT32_T.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CheckTypeSize/INT32_T.c
Linking C executable cmTryCompileExec3809821250
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3809821250.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec3809821250.dir/INT32_T.c.o  -o cmTryCompileExec3809821250 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining size of int64_t passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1897506403/fast"
make -f CMakeFiles/cmTryCompileExec1897506403.dir/build.make CMakeFiles/cmTryCompileExec1897506403.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1897506403.dir/INT64_T.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec1897506403.dir/INT64_T.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CheckTypeSize/INT64_T.c
Linking C executable cmTryCompileExec1897506403
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1897506403.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec1897506403.dir/INT64_T.c.o  -o cmTryCompileExec1897506403 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining size of intmax_t passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3045721069/fast"
make -f CMakeFiles/cmTryCompileExec3045721069.dir/build.make CMakeFiles/cmTryCompileExec3045721069.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3045721069.dir/INTMAX_T.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec3045721069.dir/INTMAX_T.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CheckTypeSize/INTMAX_T.c
Linking C executable cmTryCompileExec3045721069
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3045721069.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec3045721069.dir/INTMAX_T.c.o  -o cmTryCompileExec3045721069 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining size of uint8_t passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3379158308/fast"
make -f CMakeFiles/cmTryCompileExec3379158308.dir/build.make CMakeFiles/cmTryCompileExec3379158308.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3379158308.dir/UINT8_T.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec3379158308.dir/UINT8_T.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CheckTypeSize/UINT8_T.c
Linking C executable cmTryCompileExec3379158308
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3379158308.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec3379158308.dir/UINT8_T.c.o  -o cmTryCompileExec3379158308 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining size of uint16_t passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3980409422/fast"
make -f CMakeFiles/cmTryCompileExec3980409422.dir/build.make CMakeFiles/cmTryCompileExec3980409422.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3980409422.dir/UINT16_T.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec3980409422.dir/UINT16_T.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CheckTypeSize/UINT16_T.c
Linking C executable cmTryCompileExec3980409422
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3980409422.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec3980409422.dir/UINT16_T.c.o  -o cmTryCompileExec3980409422 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining size of uint32_t passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2567568655/fast"
make -f CMakeFiles/cmTryCompileExec2567568655.dir/build.make CMakeFiles/cmTryCompileExec2567568655.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2567568655.dir/UINT32_T.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec2567568655.dir/UINT32_T.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CheckTypeSize/UINT32_T.c
Linking C executable cmTryCompileExec2567568655
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2567568655.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec2567568655.dir/UINT32_T.c.o  -o cmTryCompileExec2567568655 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining size of uint64_t passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2604083450/fast"
make -f CMakeFiles/cmTryCompileExec2604083450.dir/build.make CMakeFiles/cmTryCompileExec2604083450.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2604083450.dir/UINT64_T.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec2604083450.dir/UINT64_T.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CheckTypeSize/UINT64_T.c
Linking C executable cmTryCompileExec2604083450
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2604083450.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec2604083450.dir/UINT64_T.c.o  -o cmTryCompileExec2604083450 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining size of uintmax_t passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec664362409/fast"
make -f CMakeFiles/cmTryCompileExec664362409.dir/build.make CMakeFiles/cmTryCompileExec664362409.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec664362409.dir/UINTMAX_T.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec664362409.dir/UINTMAX_T.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CheckTypeSize/UINTMAX_T.c
Linking C executable cmTryCompileExec664362409
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec664362409.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec664362409.dir/UINTMAX_T.c.o  -o cmTryCompileExec664362409 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining size of dev_t passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec10149946/fast"
make -f CMakeFiles/cmTryCompileExec10149946.dir/build.make CMakeFiles/cmTryCompileExec10149946.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec10149946.dir/DEV_T.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec10149946.dir/DEV_T.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CheckTypeSize/DEV_T.c
Linking C executable cmTryCompileExec10149946
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec10149946.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec10149946.dir/DEV_T.c.o  -o cmTryCompileExec10149946 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining size of gid_t passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1497568096/fast"
make -f CMakeFiles/cmTryCompileExec1497568096.dir/build.make CMakeFiles/cmTryCompileExec1497568096.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1497568096.dir/GID_T.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec1497568096.dir/GID_T.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CheckTypeSize/GID_T.c
Linking C executable cmTryCompileExec1497568096
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1497568096.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec1497568096.dir/GID_T.c.o  -o cmTryCompileExec1497568096 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining size of id_t passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1064958079/fast"
make -f CMakeFiles/cmTryCompileExec1064958079.dir/build.make CMakeFiles/cmTryCompileExec1064958079.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1064958079.dir/ID_T.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec1064958079.dir/ID_T.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CheckTypeSize/ID_T.c
Linking C executable cmTryCompileExec1064958079
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1064958079.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec1064958079.dir/ID_T.c.o  -o cmTryCompileExec1064958079 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining size of mode_t passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3547967404/fast"
make -f CMakeFiles/cmTryCompileExec3547967404.dir/build.make CMakeFiles/cmTryCompileExec3547967404.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3547967404.dir/MODE_T.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec3547967404.dir/MODE_T.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CheckTypeSize/MODE_T.c
Linking C executable cmTryCompileExec3547967404
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3547967404.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec3547967404.dir/MODE_T.c.o  -o cmTryCompileExec3547967404 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining size of off_t passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2483912640/fast"
make -f CMakeFiles/cmTryCompileExec2483912640.dir/build.make CMakeFiles/cmTryCompileExec2483912640.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2483912640.dir/OFF_T.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec2483912640.dir/OFF_T.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CheckTypeSize/OFF_T.c
Linking C executable cmTryCompileExec2483912640
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2483912640.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec2483912640.dir/OFF_T.c.o  -o cmTryCompileExec2483912640 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining size of size_t passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3827696552/fast"
make -f CMakeFiles/cmTryCompileExec3827696552.dir/build.make CMakeFiles/cmTryCompileExec3827696552.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3827696552.dir/SIZE_T.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec3827696552.dir/SIZE_T.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CheckTypeSize/SIZE_T.c
Linking C executable cmTryCompileExec3827696552
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3827696552.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec3827696552.dir/SIZE_T.c.o  -o cmTryCompileExec3827696552 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining size of ssize_t passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2040902164/fast"
make -f CMakeFiles/cmTryCompileExec2040902164.dir/build.make CMakeFiles/cmTryCompileExec2040902164.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2040902164.dir/SSIZE_T.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec2040902164.dir/SSIZE_T.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CheckTypeSize/SSIZE_T.c
Linking C executable cmTryCompileExec2040902164
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2040902164.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec2040902164.dir/SSIZE_T.c.o  -o cmTryCompileExec2040902164 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining size of uid_t passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3084866999/fast"
make -f CMakeFiles/cmTryCompileExec3084866999.dir/build.make CMakeFiles/cmTryCompileExec3084866999.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3084866999.dir/UID_T.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec3084866999.dir/UID_T.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CheckTypeSize/UID_T.c
Linking C executable cmTryCompileExec3084866999
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3084866999.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec3084866999.dir/UID_T.c.o  -o cmTryCompileExec3084866999 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining size of pid_t passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2530646480/fast"
make -f CMakeFiles/cmTryCompileExec2530646480.dir/build.make CMakeFiles/cmTryCompileExec2530646480.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2530646480.dir/PID_T.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec2530646480.dir/PID_T.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CheckTypeSize/PID_T.c
Linking C executable cmTryCompileExec2530646480
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2530646480.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec2530646480.dir/PID_T.c.o  -o cmTryCompileExec2530646480 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining size of intptr_t passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec997366185/fast"
make -f CMakeFiles/cmTryCompileExec997366185.dir/build.make CMakeFiles/cmTryCompileExec997366185.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec997366185.dir/INTPTR_T.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec997366185.dir/INTPTR_T.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CheckTypeSize/INTPTR_T.c
Linking C executable cmTryCompileExec997366185
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec997366185.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec997366185.dir/INTPTR_T.c.o  -o cmTryCompileExec997366185 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining size of uintptr_t passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3372634620/fast"
make -f CMakeFiles/cmTryCompileExec3372634620.dir/build.make CMakeFiles/cmTryCompileExec3372634620.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3372634620.dir/UINTPTR_T.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec3372634620.dir/UINTPTR_T.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CheckTypeSize/UINTPTR_T.c
Linking C executable cmTryCompileExec3372634620
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3372634620.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec3372634620.dir/UINTPTR_T.c.o  -o cmTryCompileExec3372634620 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining size of wchar_t passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1337278408/fast"
make -f CMakeFiles/cmTryCompileExec1337278408.dir/build.make CMakeFiles/cmTryCompileExec1337278408.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1337278408.dir/SIZEOF_WCHAR_T.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec1337278408.dir/SIZEOF_WCHAR_T.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CheckTypeSize/SIZEOF_WCHAR_T.c
Linking C executable cmTryCompileExec1337278408
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1337278408.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec1337278408.dir/SIZEOF_WCHAR_T.c.o  -o cmTryCompileExec1337278408 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Checking support for ARCHIVE_CRYPTO_MD5_LIBC failed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3651764498/fast"
make -f CMakeFiles/cmTryCompileExec3651764498.dir/build.make CMakeFiles/cmTryCompileExec3651764498.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3651764498.dir/check_crypto_md.c.o
/usr/bin/gcc   -w   -I/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Utilities/cmlibarchive/libarchive -I/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec3651764498.dir/check_crypto_md.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:61:17: error: md5.h: No such file or directory
In file included from /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:156: error: expected ‘=’, ‘,’, ‘;’, ‘asm’ or ‘__attribute__’ before ‘archive_md5_ctx’
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:354: error: expected ‘)’ before ‘*’ token
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:355: error: expected ‘;’ before ‘int’
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:117: error: expected ‘)’ before ‘*’ token
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:124: error: expected ‘)’ before ‘*’ token
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:132: error: expected ‘)’ before ‘*’ token
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1237: error: ‘__archive_libc_md5init’ undeclared here (not in a function)
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1238: error: ‘__archive_libc_md5update’ undeclared here (not in a function)
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1239: error: ‘__archive_libc_md5final’ undeclared here (not in a function)
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c: In function ‘main’:
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: ‘archive__ctx’ undeclared (first use in this function)
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: (Each undeclared identifier is reported only once
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: for each function it appears in.)
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: expected ‘;’ before ‘ctx’
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1439: error: ‘ctx’ undeclared (first use in this function)
make[1]: *** [CMakeFiles/cmTryCompileExec3651764498.dir/check_crypto_md.c.o] Error 1
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
make: *** [cmTryCompileExec3651764498/fast] Error 2

Source file was:

#define ARCHIVE_MD5_COMPILE_TEST
#define ARCHIVE_CRYPTO_MD5_LIBC
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. OpenSSL
 * 6. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive__ctx ctx;
  archive__init(&ctx);
  archive__update(&ctx, *argv, argc);
  archive__final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_RMD160_LIBC failed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3142817411/fast"
make -f CMakeFiles/cmTryCompileExec3142817411.dir/build.make CMakeFiles/cmTryCompileExec3142817411.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3142817411.dir/check_crypto_md.c.o
/usr/bin/gcc   -w   -I/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Utilities/cmlibarchive/libarchive -I/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec3142817411.dir/check_crypto_md.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:64:20: error: rmd160.h: No such file or directory
In file included from /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:172: error: expected ‘=’, ‘,’, ‘;’, ‘asm’ or ‘__attribute__’ before ‘archive_rmd160_ctx’
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:357: error: expected ‘)’ before ‘*’ token
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:358: error: expected ‘;’ before ‘int’
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:293: error: expected ‘)’ before ‘*’ token
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:300: error: expected ‘)’ before ‘*’ token
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:308: error: expected ‘)’ before ‘*’ token
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1268: error: ‘__archive_libc_ripemd160init’ undeclared here (not in a function)
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1269: error: ‘__archive_libc_ripemd160update’ undeclared here (not in a function)
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1270: error: ‘__archive_libc_ripemd160final’ undeclared here (not in a function)
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c: In function ‘main’:
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: ‘archive__ctx’ undeclared (first use in this function)
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: (Each undeclared identifier is reported only once
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: for each function it appears in.)
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: expected ‘;’ before ‘ctx’
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1439: error: ‘ctx’ undeclared (first use in this function)
make[1]: *** [CMakeFiles/cmTryCompileExec3142817411.dir/check_crypto_md.c.o] Error 1
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
make: *** [cmTryCompileExec3142817411/fast] Error 2

Source file was:

#define ARCHIVE_RMD160_COMPILE_TEST
#define ARCHIVE_CRYPTO_RMD160_LIBC
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. OpenSSL
 * 6. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive__ctx ctx;
  archive__init(&ctx);
  archive__update(&ctx, *argv, argc);
  archive__final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_SHA1_LIBC failed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1671686423/fast"
make -f CMakeFiles/cmTryCompileExec1671686423.dir/build.make CMakeFiles/cmTryCompileExec1671686423.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1671686423.dir/check_crypto_md.c.o
/usr/bin/gcc   -w   -I/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Utilities/cmlibarchive/libarchive -I/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec1671686423.dir/check_crypto_md.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:67:18: error: sha1.h: No such file or directory
In file included from /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:184: error: expected ‘=’, ‘,’, ‘;’, ‘asm’ or ‘__attribute__’ before ‘archive_sha1_ctx’
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:360: error: expected ‘)’ before ‘*’ token
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:361: error: expected ‘;’ before ‘int’
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:419: error: expected ‘)’ before ‘*’ token
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:426: error: expected ‘)’ before ‘*’ token
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:434: error: expected ‘)’ before ‘*’ token
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1291: error: ‘__archive_libc_sha1init’ undeclared here (not in a function)
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1292: error: ‘__archive_libc_sha1update’ undeclared here (not in a function)
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1293: error: ‘__archive_libc_sha1final’ undeclared here (not in a function)
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c: In function ‘main’:
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: ‘archive__ctx’ undeclared (first use in this function)
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: (Each undeclared identifier is reported only once
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: for each function it appears in.)
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: expected ‘;’ before ‘ctx’
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1439: error: ‘ctx’ undeclared (first use in this function)
make[1]: *** [CMakeFiles/cmTryCompileExec1671686423.dir/check_crypto_md.c.o] Error 1
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
make: *** [cmTryCompileExec1671686423/fast] Error 2

Source file was:

#define ARCHIVE_SHA1_COMPILE_TEST
#define ARCHIVE_CRYPTO_SHA1_LIBC
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. OpenSSL
 * 6. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive__ctx ctx;
  archive__init(&ctx);
  archive__update(&ctx, *argv, argc);
  archive__final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_SHA256_LIBC failed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2075933665/fast"
make -f CMakeFiles/cmTryCompileExec2075933665.dir/build.make CMakeFiles/cmTryCompileExec2075933665.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2075933665.dir/check_crypto_md.c.o
/usr/bin/gcc   -w   -I/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Utilities/cmlibarchive/libarchive -I/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec2075933665.dir/check_crypto_md.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:78:18: error: sha2.h: No such file or directory
In file included from /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:200: error: expected ‘=’, ‘,’, ‘;’, ‘asm’ or ‘__attribute__’ before ‘archive_sha256_ctx’
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:363: error: expected ‘)’ before ‘*’ token
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:364: error: expected ‘;’ before ‘int’
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:595: error: expected ‘)’ before ‘*’ token
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:602: error: expected ‘)’ before ‘*’ token
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:610: error: expected ‘)’ before ‘*’ token
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1322: error: ‘__archive_libc_sha256init’ undeclared here (not in a function)
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1323: error: ‘__archive_libc_sha256update’ undeclared here (not in a function)
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1324: error: ‘__archive_libc_sha256final’ undeclared here (not in a function)
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c: In function ‘main’:
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: ‘archive__ctx’ undeclared (first use in this function)
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: (Each undeclared identifier is reported only once
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: for each function it appears in.)
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: expected ‘;’ before ‘ctx’
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1439: error: ‘ctx’ undeclared (first use in this function)
make[1]: *** [CMakeFiles/cmTryCompileExec2075933665.dir/check_crypto_md.c.o] Error 1
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
make: *** [cmTryCompileExec2075933665/fast] Error 2

Source file was:

#define ARCHIVE_SHA256_COMPILE_TEST
#define ARCHIVE_CRYPTO_SHA256_LIBC
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. OpenSSL
 * 6. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive__ctx ctx;
  archive__init(&ctx);
  archive__update(&ctx, *argv, argc);
  archive__final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_SHA384_LIBC failed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1683305772/fast"
make -f CMakeFiles/cmTryCompileExec1683305772.dir/build.make CMakeFiles/cmTryCompileExec1683305772.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1683305772.dir/check_crypto_md.c.o
/usr/bin/gcc   -w   -I/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Utilities/cmlibarchive/libarchive -I/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec1683305772.dir/check_crypto_md.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:78:18: error: sha2.h: No such file or directory
In file included from /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:220: error: expected ‘=’, ‘,’, ‘;’, ‘asm’ or ‘__attribute__’ before ‘archive_sha384_ctx’
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:366: error: expected ‘)’ before ‘*’ token
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:367: error: expected ‘;’ before ‘int’
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:814: error: expected ‘)’ before ‘*’ token
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:821: error: expected ‘)’ before ‘*’ token
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:829: error: expected ‘)’ before ‘*’ token
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1361: error: ‘__archive_libc_sha384init’ undeclared here (not in a function)
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1362: error: ‘__archive_libc_sha384update’ undeclared here (not in a function)
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1363: error: ‘__archive_libc_sha384final’ undeclared here (not in a function)
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c: In function ‘main’:
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: ‘archive__ctx’ undeclared (first use in this function)
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: (Each undeclared identifier is reported only once
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: for each function it appears in.)
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: expected ‘;’ before ‘ctx’
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1439: error: ‘ctx’ undeclared (first use in this function)
make[1]: *** [CMakeFiles/cmTryCompileExec1683305772.dir/check_crypto_md.c.o] Error 1
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
make: *** [cmTryCompileExec1683305772/fast] Error 2

Source file was:

#define ARCHIVE_SHA384_COMPILE_TEST
#define ARCHIVE_CRYPTO_SHA384_LIBC
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. OpenSSL
 * 6. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive__ctx ctx;
  archive__init(&ctx);
  archive__update(&ctx, *argv, argc);
  archive__final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_SHA512_LIBC failed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1411526728/fast"
make -f CMakeFiles/cmTryCompileExec1411526728.dir/build.make CMakeFiles/cmTryCompileExec1411526728.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1411526728.dir/check_crypto_md.c.o
/usr/bin/gcc   -w   -I/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Utilities/cmlibarchive/libarchive -I/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec1411526728.dir/check_crypto_md.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:78:18: error: sha2.h: No such file or directory
In file included from /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:238: error: expected ‘=’, ‘,’, ‘;’, ‘asm’ or ‘__attribute__’ before ‘archive_sha512_ctx’
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:369: error: expected ‘)’ before ‘*’ token
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:370: error: expected ‘;’ before ‘int’
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1009: error: expected ‘)’ before ‘*’ token
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1016: error: expected ‘)’ before ‘*’ token
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1024: error: expected ‘)’ before ‘*’ token
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1396: error: ‘__archive_libc_sha512init’ undeclared here (not in a function)
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1397: error: ‘__archive_libc_sha512update’ undeclared here (not in a function)
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1398: error: ‘__archive_libc_sha512final’ undeclared here (not in a function)
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c: In function ‘main’:
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: ‘archive__ctx’ undeclared (first use in this function)
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: (Each undeclared identifier is reported only once
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: for each function it appears in.)
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: expected ‘;’ before ‘ctx’
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1439: error: ‘ctx’ undeclared (first use in this function)
make[1]: *** [CMakeFiles/cmTryCompileExec1411526728.dir/check_crypto_md.c.o] Error 1
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
make: *** [cmTryCompileExec1411526728/fast] Error 2

Source file was:

#define ARCHIVE_SHA512_COMPILE_TEST
#define ARCHIVE_CRYPTO_SHA512_LIBC
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. OpenSSL
 * 6. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive__ctx ctx;
  archive__init(&ctx);
  archive__update(&ctx, *argv, argc);
  archive__final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_SHA256_LIBC2 failed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1224388737/fast"
make -f CMakeFiles/cmTryCompileExec1224388737.dir/build.make CMakeFiles/cmTryCompileExec1224388737.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1224388737.dir/check_crypto_md.c.o
/usr/bin/gcc   -w   -I/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Utilities/cmlibarchive/libarchive -I/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec1224388737.dir/check_crypto_md.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:78:18: error: sha2.h: No such file or directory
In file included from /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:202: error: expected ‘=’, ‘,’, ‘;’, ‘asm’ or ‘__attribute__’ before ‘archive_sha256_ctx’
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:363: error: expected ‘)’ before ‘*’ token
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:364: error: expected ‘;’ before ‘int’
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:619: error: expected ‘)’ before ‘*’ token
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:626: error: expected ‘)’ before ‘*’ token
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:634: error: expected ‘)’ before ‘*’ token
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1326: error: ‘__archive_libc2_sha256init’ undeclared here (not in a function)
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1327: error: ‘__archive_libc2_sha256update’ undeclared here (not in a function)
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1328: error: ‘__archive_libc2_sha256final’ undeclared here (not in a function)
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c: In function ‘main’:
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: ‘archive__ctx’ undeclared (first use in this function)
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: (Each undeclared identifier is reported only once
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: for each function it appears in.)
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: expected ‘;’ before ‘ctx’
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1439: error: ‘ctx’ undeclared (first use in this function)
make[1]: *** [CMakeFiles/cmTryCompileExec1224388737.dir/check_crypto_md.c.o] Error 1
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
make: *** [cmTryCompileExec1224388737/fast] Error 2

Source file was:

#define ARCHIVE_SHA256_COMPILE_TEST
#define ARCHIVE_CRYPTO_SHA256_LIBC2
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. OpenSSL
 * 6. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive__ctx ctx;
  archive__init(&ctx);
  archive__update(&ctx, *argv, argc);
  archive__final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_SHA384_LIBC2 failed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec23673004/fast"
make -f CMakeFiles/cmTryCompileExec23673004.dir/build.make CMakeFiles/cmTryCompileExec23673004.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec23673004.dir/check_crypto_md.c.o
/usr/bin/gcc   -w   -I/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Utilities/cmlibarchive/libarchive -I/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec23673004.dir/check_crypto_md.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:78:18: error: sha2.h: No such file or directory
In file included from /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:222: error: expected ‘=’, ‘,’, ‘;’, ‘asm’ or ‘__attribute__’ before ‘archive_sha384_ctx’
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:366: error: expected ‘)’ before ‘*’ token
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:367: error: expected ‘;’ before ‘int’
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:838: error: expected ‘)’ before ‘*’ token
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:845: error: expected ‘)’ before ‘*’ token
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:853: error: expected ‘)’ before ‘*’ token
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1365: error: ‘__archive_libc2_sha384init’ undeclared here (not in a function)
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1366: error: ‘__archive_libc2_sha384update’ undeclared here (not in a function)
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1367: error: ‘__archive_libc2_sha384final’ undeclared here (not in a function)
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c: In function ‘main’:
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: ‘archive__ctx’ undeclared (first use in this function)
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: (Each undeclared identifier is reported only once
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: for each function it appears in.)
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: expected ‘;’ before ‘ctx’
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1439: error: ‘ctx’ undeclared (first use in this function)
make[1]: *** [CMakeFiles/cmTryCompileExec23673004.dir/check_crypto_md.c.o] Error 1
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
make: *** [cmTryCompileExec23673004/fast] Error 2

Source file was:

#define ARCHIVE_SHA384_COMPILE_TEST
#define ARCHIVE_CRYPTO_SHA384_LIBC2
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. OpenSSL
 * 6. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive__ctx ctx;
  archive__init(&ctx);
  archive__update(&ctx, *argv, argc);
  archive__final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_SHA512_LIBC2 failed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec679128157/fast"
make -f CMakeFiles/cmTryCompileExec679128157.dir/build.make CMakeFiles/cmTryCompileExec679128157.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec679128157.dir/check_crypto_md.c.o
/usr/bin/gcc   -w   -I/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Utilities/cmlibarchive/libarchive -I/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec679128157.dir/check_crypto_md.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:78:18: error: sha2.h: No such file or directory
In file included from /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:240: error: expected ‘=’, ‘,’, ‘;’, ‘asm’ or ‘__attribute__’ before ‘archive_sha512_ctx’
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:369: error: expected ‘)’ before ‘*’ token
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:370: error: expected ‘;’ before ‘int’
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1033: error: expected ‘)’ before ‘*’ token
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1040: error: expected ‘)’ before ‘*’ token
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1048: error: expected ‘)’ before ‘*’ token
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1400: error: ‘__archive_libc2_sha512init’ undeclared here (not in a function)
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1401: error: ‘__archive_libc2_sha512update’ undeclared here (not in a function)
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1402: error: ‘__archive_libc2_sha512final’ undeclared here (not in a function)
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c: In function ‘main’:
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: ‘archive__ctx’ undeclared (first use in this function)
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: (Each undeclared identifier is reported only once
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: for each function it appears in.)
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: expected ‘;’ before ‘ctx’
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1439: error: ‘ctx’ undeclared (first use in this function)
make[1]: *** [CMakeFiles/cmTryCompileExec679128157.dir/check_crypto_md.c.o] Error 1
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
make: *** [cmTryCompileExec679128157/fast] Error 2

Source file was:

#define ARCHIVE_SHA512_COMPILE_TEST
#define ARCHIVE_CRYPTO_SHA512_LIBC2
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. OpenSSL
 * 6. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive__ctx ctx;
  archive__init(&ctx);
  archive__update(&ctx, *argv, argc);
  archive__final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_SHA256_LIBC3 failed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1973062011/fast"
make -f CMakeFiles/cmTryCompileExec1973062011.dir/build.make CMakeFiles/cmTryCompileExec1973062011.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1973062011.dir/check_crypto_md.c.o
/usr/bin/gcc   -w   -I/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Utilities/cmlibarchive/libarchive -I/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec1973062011.dir/check_crypto_md.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:78:18: error: sha2.h: No such file or directory
In file included from /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:204: error: expected ‘=’, ‘,’, ‘;’, ‘asm’ or ‘__attribute__’ before ‘archive_sha256_ctx’
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:363: error: expected ‘)’ before ‘*’ token
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:364: error: expected ‘;’ before ‘int’
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:643: error: expected ‘)’ before ‘*’ token
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:650: error: expected ‘)’ before ‘*’ token
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:658: error: expected ‘)’ before ‘*’ token
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1330: error: ‘__archive_libc3_sha256init’ undeclared here (not in a function)
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1331: error: ‘__archive_libc3_sha256update’ undeclared here (not in a function)
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1332: error: ‘__archive_libc3_sha256final’ undeclared here (not in a function)
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c: In function ‘main’:
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: ‘archive__ctx’ undeclared (first use in this function)
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: (Each undeclared identifier is reported only once
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: for each function it appears in.)
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: expected ‘;’ before ‘ctx’
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1439: error: ‘ctx’ undeclared (first use in this function)
make[1]: *** [CMakeFiles/cmTryCompileExec1973062011.dir/check_crypto_md.c.o] Error 1
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
make: *** [cmTryCompileExec1973062011/fast] Error 2

Source file was:

#define ARCHIVE_SHA256_COMPILE_TEST
#define ARCHIVE_CRYPTO_SHA256_LIBC3
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. OpenSSL
 * 6. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive__ctx ctx;
  archive__init(&ctx);
  archive__update(&ctx, *argv, argc);
  archive__final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_SHA384_LIBC3 failed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec222973287/fast"
make -f CMakeFiles/cmTryCompileExec222973287.dir/build.make CMakeFiles/cmTryCompileExec222973287.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec222973287.dir/check_crypto_md.c.o
/usr/bin/gcc   -w   -I/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Utilities/cmlibarchive/libarchive -I/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec222973287.dir/check_crypto_md.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:78:18: error: sha2.h: No such file or directory
In file included from /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:224: error: expected ‘=’, ‘,’, ‘;’, ‘asm’ or ‘__attribute__’ before ‘archive_sha384_ctx’
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:366: error: expected ‘)’ before ‘*’ token
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:367: error: expected ‘;’ before ‘int’
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:862: error: expected ‘)’ before ‘*’ token
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:869: error: expected ‘)’ before ‘*’ token
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:877: error: expected ‘)’ before ‘*’ token
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1369: error: ‘__archive_libc3_sha384init’ undeclared here (not in a function)
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1370: error: ‘__archive_libc3_sha384update’ undeclared here (not in a function)
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1371: error: ‘__archive_libc3_sha384final’ undeclared here (not in a function)
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c: In function ‘main’:
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: ‘archive__ctx’ undeclared (first use in this function)
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: (Each undeclared identifier is reported only once
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: for each function it appears in.)
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: expected ‘;’ before ‘ctx’
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1439: error: ‘ctx’ undeclared (first use in this function)
make[1]: *** [CMakeFiles/cmTryCompileExec222973287.dir/check_crypto_md.c.o] Error 1
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
make: *** [cmTryCompileExec222973287/fast] Error 2

Source file was:

#define ARCHIVE_SHA384_COMPILE_TEST
#define ARCHIVE_CRYPTO_SHA384_LIBC3
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. OpenSSL
 * 6. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive__ctx ctx;
  archive__init(&ctx);
  archive__update(&ctx, *argv, argc);
  archive__final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_SHA512_LIBC3 failed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1116210442/fast"
make -f CMakeFiles/cmTryCompileExec1116210442.dir/build.make CMakeFiles/cmTryCompileExec1116210442.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1116210442.dir/check_crypto_md.c.o
/usr/bin/gcc   -w   -I/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Utilities/cmlibarchive/libarchive -I/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec1116210442.dir/check_crypto_md.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:78:18: error: sha2.h: No such file or directory
In file included from /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:242: error: expected ‘=’, ‘,’, ‘;’, ‘asm’ or ‘__attribute__’ before ‘archive_sha512_ctx’
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:369: error: expected ‘)’ before ‘*’ token
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:370: error: expected ‘;’ before ‘int’
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1057: error: expected ‘)’ before ‘*’ token
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1064: error: expected ‘)’ before ‘*’ token
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1072: error: expected ‘)’ before ‘*’ token
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1404: error: ‘__archive_libc3_sha512init’ undeclared here (not in a function)
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1405: error: ‘__archive_libc3_sha512update’ undeclared here (not in a function)
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1406: error: ‘__archive_libc3_sha512final’ undeclared here (not in a function)
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c: In function ‘main’:
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: ‘archive__ctx’ undeclared (first use in this function)
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: (Each undeclared identifier is reported only once
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: for each function it appears in.)
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: expected ‘;’ before ‘ctx’
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1439: error: ‘ctx’ undeclared (first use in this function)
make[1]: *** [CMakeFiles/cmTryCompileExec1116210442.dir/check_crypto_md.c.o] Error 1
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
make: *** [cmTryCompileExec1116210442/fast] Error 2

Source file was:

#define ARCHIVE_SHA512_COMPILE_TEST
#define ARCHIVE_CRYPTO_SHA512_LIBC3
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. OpenSSL
 * 6. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive__ctx ctx;
  archive__init(&ctx);
  archive__update(&ctx, *argv, argc);
  archive__final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_MD5_LIBSYSTEM failed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2559262508/fast"
make -f CMakeFiles/cmTryCompileExec2559262508.dir/build.make CMakeFiles/cmTryCompileExec2559262508.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2559262508.dir/check_crypto_md.c.o
/usr/bin/gcc   -w   -I/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Utilities/cmlibarchive/libarchive -I/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec2559262508.dir/check_crypto_md.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:112:39: error: CommonCrypto/CommonDigest.h: No such file or directory
In file included from /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:160: error: expected ‘=’, ‘,’, ‘;’, ‘asm’ or ‘__attribute__’ before ‘archive_md5_ctx’
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:354: error: expected ‘)’ before ‘*’ token
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:355: error: expected ‘;’ before ‘int’
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:165: error: expected ‘)’ before ‘*’ token
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:172: error: expected ‘)’ before ‘*’ token
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:180: error: expected ‘)’ before ‘*’ token
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1245: error: ‘__archive_libsystem_md5init’ undeclared here (not in a function)
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1246: error: ‘__archive_libsystem_md5update’ undeclared here (not in a function)
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1247: error: ‘__archive_libsystem_md5final’ undeclared here (not in a function)
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c: In function ‘main’:
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: ‘archive__ctx’ undeclared (first use in this function)
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: (Each undeclared identifier is reported only once
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: for each function it appears in.)
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: expected ‘;’ before ‘ctx’
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1439: error: ‘ctx’ undeclared (first use in this function)
make[1]: *** [CMakeFiles/cmTryCompileExec2559262508.dir/check_crypto_md.c.o] Error 1
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
make: *** [cmTryCompileExec2559262508/fast] Error 2

Source file was:

#define ARCHIVE_MD5_COMPILE_TEST
#define ARCHIVE_CRYPTO_MD5_LIBSYSTEM
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. OpenSSL
 * 6. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive__ctx ctx;
  archive__init(&ctx);
  archive__update(&ctx, *argv, argc);
  archive__final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_SHA1_LIBSYSTEM failed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3737945243/fast"
make -f CMakeFiles/cmTryCompileExec3737945243.dir/build.make CMakeFiles/cmTryCompileExec3737945243.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3737945243.dir/check_crypto_md.c.o
/usr/bin/gcc   -w   -I/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Utilities/cmlibarchive/libarchive -I/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec3737945243.dir/check_crypto_md.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:112:39: error: CommonCrypto/CommonDigest.h: No such file or directory
In file included from /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:188: error: expected ‘=’, ‘,’, ‘;’, ‘asm’ or ‘__attribute__’ before ‘archive_sha1_ctx’
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:360: error: expected ‘)’ before ‘*’ token
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:361: error: expected ‘;’ before ‘int’
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:467: error: expected ‘)’ before ‘*’ token
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:474: error: expected ‘)’ before ‘*’ token
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:482: error: expected ‘)’ before ‘*’ token
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1299: error: ‘__archive_libsystem_sha1init’ undeclared here (not in a function)
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1300: error: ‘__archive_libsystem_sha1update’ undeclared here (not in a function)
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1301: error: ‘__archive_libsystem_sha1final’ undeclared here (not in a function)
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c: In function ‘main’:
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: ‘archive__ctx’ undeclared (first use in this function)
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: (Each undeclared identifier is reported only once
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: for each function it appears in.)
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: expected ‘;’ before ‘ctx’
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1439: error: ‘ctx’ undeclared (first use in this function)
make[1]: *** [CMakeFiles/cmTryCompileExec3737945243.dir/check_crypto_md.c.o] Error 1
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
make: *** [cmTryCompileExec3737945243/fast] Error 2

Source file was:

#define ARCHIVE_SHA1_COMPILE_TEST
#define ARCHIVE_CRYPTO_SHA1_LIBSYSTEM
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. OpenSSL
 * 6. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive__ctx ctx;
  archive__init(&ctx);
  archive__update(&ctx, *argv, argc);
  archive__final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_SHA256_LIBSYSTEM failed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec306908866/fast"
make -f CMakeFiles/cmTryCompileExec306908866.dir/build.make CMakeFiles/cmTryCompileExec306908866.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec306908866.dir/check_crypto_md.c.o
/usr/bin/gcc   -w   -I/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Utilities/cmlibarchive/libarchive -I/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec306908866.dir/check_crypto_md.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:112:39: error: CommonCrypto/CommonDigest.h: No such file or directory
In file included from /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:208: error: expected ‘=’, ‘,’, ‘;’, ‘asm’ or ‘__attribute__’ before ‘archive_sha256_ctx’
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:363: error: expected ‘)’ before ‘*’ token
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:364: error: expected ‘;’ before ‘int’
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:691: error: expected ‘)’ before ‘*’ token
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:698: error: expected ‘)’ before ‘*’ token
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:706: error: expected ‘)’ before ‘*’ token
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1338: error: ‘__archive_libsystem_sha256init’ undeclared here (not in a function)
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1339: error: ‘__archive_libsystem_sha256update’ undeclared here (not in a function)
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1340: error: ‘__archive_libsystem_sha256final’ undeclared here (not in a function)
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c: In function ‘main’:
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: ‘archive__ctx’ undeclared (first use in this function)
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: (Each undeclared identifier is reported only once
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: for each function it appears in.)
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: expected ‘;’ before ‘ctx’
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1439: error: ‘ctx’ undeclared (first use in this function)
make[1]: *** [CMakeFiles/cmTryCompileExec306908866.dir/check_crypto_md.c.o] Error 1
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
make: *** [cmTryCompileExec306908866/fast] Error 2

Source file was:

#define ARCHIVE_SHA256_COMPILE_TEST
#define ARCHIVE_CRYPTO_SHA256_LIBSYSTEM
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. OpenSSL
 * 6. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive__ctx ctx;
  archive__init(&ctx);
  archive__update(&ctx, *argv, argc);
  archive__final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_SHA384_LIBSYSTEM failed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1186888786/fast"
make -f CMakeFiles/cmTryCompileExec1186888786.dir/build.make CMakeFiles/cmTryCompileExec1186888786.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1186888786.dir/check_crypto_md.c.o
/usr/bin/gcc   -w   -I/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Utilities/cmlibarchive/libarchive -I/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec1186888786.dir/check_crypto_md.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:112:39: error: CommonCrypto/CommonDigest.h: No such file or directory
In file included from /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:226: error: expected ‘=’, ‘,’, ‘;’, ‘asm’ or ‘__attribute__’ before ‘archive_sha384_ctx’
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:366: error: expected ‘)’ before ‘*’ token
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:367: error: expected ‘;’ before ‘int’
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:886: error: expected ‘)’ before ‘*’ token
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:893: error: expected ‘)’ before ‘*’ token
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:901: error: expected ‘)’ before ‘*’ token
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1373: error: ‘__archive_libsystem_sha384init’ undeclared here (not in a function)
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1374: error: ‘__archive_libsystem_sha384update’ undeclared here (not in a function)
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1375: error: ‘__archive_libsystem_sha384final’ undeclared here (not in a function)
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c: In function ‘main’:
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: ‘archive__ctx’ undeclared (first use in this function)
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: (Each undeclared identifier is reported only once
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: for each function it appears in.)
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: expected ‘;’ before ‘ctx’
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1439: error: ‘ctx’ undeclared (first use in this function)
make[1]: *** [CMakeFiles/cmTryCompileExec1186888786.dir/check_crypto_md.c.o] Error 1
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
make: *** [cmTryCompileExec1186888786/fast] Error 2

Source file was:

#define ARCHIVE_SHA384_COMPILE_TEST
#define ARCHIVE_CRYPTO_SHA384_LIBSYSTEM
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. OpenSSL
 * 6. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive__ctx ctx;
  archive__init(&ctx);
  archive__update(&ctx, *argv, argc);
  archive__final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_SHA512_LIBSYSTEM failed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec995681644/fast"
make -f CMakeFiles/cmTryCompileExec995681644.dir/build.make CMakeFiles/cmTryCompileExec995681644.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec995681644.dir/check_crypto_md.c.o
/usr/bin/gcc   -w   -I/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Utilities/cmlibarchive/libarchive -I/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec995681644.dir/check_crypto_md.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:112:39: error: CommonCrypto/CommonDigest.h: No such file or directory
In file included from /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:246: error: expected ‘=’, ‘,’, ‘;’, ‘asm’ or ‘__attribute__’ before ‘archive_sha512_ctx’
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:369: error: expected ‘)’ before ‘*’ token
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:370: error: expected ‘;’ before ‘int’
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1105: error: expected ‘)’ before ‘*’ token
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1112: error: expected ‘)’ before ‘*’ token
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1120: error: expected ‘)’ before ‘*’ token
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1412: error: ‘__archive_libsystem_sha512init’ undeclared here (not in a function)
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1413: error: ‘__archive_libsystem_sha512update’ undeclared here (not in a function)
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1414: error: ‘__archive_libsystem_sha512final’ undeclared here (not in a function)
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c: In function ‘main’:
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: ‘archive__ctx’ undeclared (first use in this function)
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: (Each undeclared identifier is reported only once
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: for each function it appears in.)
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: expected ‘;’ before ‘ctx’
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1439: error: ‘ctx’ undeclared (first use in this function)
make[1]: *** [CMakeFiles/cmTryCompileExec995681644.dir/check_crypto_md.c.o] Error 1
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
make: *** [cmTryCompileExec995681644/fast] Error 2

Source file was:

#define ARCHIVE_SHA512_COMPILE_TEST
#define ARCHIVE_CRYPTO_SHA512_LIBSYSTEM
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. OpenSSL
 * 6. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive__ctx ctx;
  archive__init(&ctx);
  archive__update(&ctx, *argv, argc);
  archive__final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_MD5_LIBMD failed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec69773915/fast"
make -f CMakeFiles/cmTryCompileExec69773915.dir/build.make CMakeFiles/cmTryCompileExec69773915.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec69773915.dir/check_crypto_md.c.o
/usr/bin/gcc   -w   -I/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Utilities/cmlibarchive/libarchive -I/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec69773915.dir/check_crypto_md.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:91:17: error: md5.h: No such file or directory
In file included from /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:158: error: expected ‘=’, ‘,’, ‘;’, ‘asm’ or ‘__attribute__’ before ‘archive_md5_ctx’
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:354: error: expected ‘)’ before ‘*’ token
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:355: error: expected ‘;’ before ‘int’
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:141: error: expected ‘)’ before ‘*’ token
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:148: error: expected ‘)’ before ‘*’ token
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:156: error: expected ‘)’ before ‘*’ token
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1241: error: ‘__archive_libmd_md5init’ undeclared here (not in a function)
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1242: error: ‘__archive_libmd_md5update’ undeclared here (not in a function)
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1243: error: ‘__archive_libmd_md5final’ undeclared here (not in a function)
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c: In function ‘main’:
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: ‘archive__ctx’ undeclared (first use in this function)
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: (Each undeclared identifier is reported only once
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: for each function it appears in.)
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: expected ‘;’ before ‘ctx’
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1439: error: ‘ctx’ undeclared (first use in this function)
make[1]: *** [CMakeFiles/cmTryCompileExec69773915.dir/check_crypto_md.c.o] Error 1
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
make: *** [cmTryCompileExec69773915/fast] Error 2

Source file was:

#define ARCHIVE_MD5_COMPILE_TEST
#define ARCHIVE_CRYPTO_MD5_LIBMD
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. OpenSSL
 * 6. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive__ctx ctx;
  archive__init(&ctx);
  archive__update(&ctx, *argv, argc);
  archive__final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_RMD160_LIBMD failed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec627959534/fast"
make -f CMakeFiles/cmTryCompileExec627959534.dir/build.make CMakeFiles/cmTryCompileExec627959534.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec627959534.dir/check_crypto_md.c.o
/usr/bin/gcc   -w   -I/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Utilities/cmlibarchive/libarchive -I/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec627959534.dir/check_crypto_md.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:94:20: error: ripemd.h: No such file or directory
In file included from /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:174: error: expected ‘=’, ‘,’, ‘;’, ‘asm’ or ‘__attribute__’ before ‘archive_rmd160_ctx’
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:357: error: expected ‘)’ before ‘*’ token
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:358: error: expected ‘;’ before ‘int’
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:317: error: expected ‘)’ before ‘*’ token
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:324: error: expected ‘)’ before ‘*’ token
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:332: error: expected ‘)’ before ‘*’ token
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1272: error: ‘__archive_libmd_ripemd160init’ undeclared here (not in a function)
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1273: error: ‘__archive_libmd_ripemd160update’ undeclared here (not in a function)
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1274: error: ‘__archive_libmd_ripemd160final’ undeclared here (not in a function)
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c: In function ‘main’:
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: ‘archive__ctx’ undeclared (first use in this function)
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: (Each undeclared identifier is reported only once
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: for each function it appears in.)
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: expected ‘;’ before ‘ctx’
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1439: error: ‘ctx’ undeclared (first use in this function)
make[1]: *** [CMakeFiles/cmTryCompileExec627959534.dir/check_crypto_md.c.o] Error 1
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
make: *** [cmTryCompileExec627959534/fast] Error 2

Source file was:

#define ARCHIVE_RMD160_COMPILE_TEST
#define ARCHIVE_CRYPTO_RMD160_LIBMD
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. OpenSSL
 * 6. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive__ctx ctx;
  archive__init(&ctx);
  archive__update(&ctx, *argv, argc);
  archive__final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_SHA1_LIBMD failed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec837473298/fast"
make -f CMakeFiles/cmTryCompileExec837473298.dir/build.make CMakeFiles/cmTryCompileExec837473298.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec837473298.dir/check_crypto_md.c.o
/usr/bin/gcc   -w   -I/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Utilities/cmlibarchive/libarchive -I/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec837473298.dir/check_crypto_md.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:97:17: error: sha.h: No such file or directory
In file included from /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:186: error: expected ‘=’, ‘,’, ‘;’, ‘asm’ or ‘__attribute__’ before ‘archive_sha1_ctx’
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:360: error: expected ‘)’ before ‘*’ token
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:361: error: expected ‘;’ before ‘int’
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:443: error: expected ‘)’ before ‘*’ token
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:450: error: expected ‘)’ before ‘*’ token
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:458: error: expected ‘)’ before ‘*’ token
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1295: error: ‘__archive_libmd_sha1init’ undeclared here (not in a function)
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1296: error: ‘__archive_libmd_sha1update’ undeclared here (not in a function)
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1297: error: ‘__archive_libmd_sha1final’ undeclared here (not in a function)
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c: In function ‘main’:
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: ‘archive__ctx’ undeclared (first use in this function)
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: (Each undeclared identifier is reported only once
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: for each function it appears in.)
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: expected ‘;’ before ‘ctx’
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1439: error: ‘ctx’ undeclared (first use in this function)
make[1]: *** [CMakeFiles/cmTryCompileExec837473298.dir/check_crypto_md.c.o] Error 1
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
make: *** [cmTryCompileExec837473298/fast] Error 2

Source file was:

#define ARCHIVE_SHA1_COMPILE_TEST
#define ARCHIVE_CRYPTO_SHA1_LIBMD
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. OpenSSL
 * 6. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive__ctx ctx;
  archive__init(&ctx);
  archive__update(&ctx, *argv, argc);
  archive__final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_SHA256_LIBMD failed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2397044773/fast"
make -f CMakeFiles/cmTryCompileExec2397044773.dir/build.make CMakeFiles/cmTryCompileExec2397044773.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2397044773.dir/check_crypto_md.c.o
/usr/bin/gcc   -w   -I/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Utilities/cmlibarchive/libarchive -I/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec2397044773.dir/check_crypto_md.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:100:20: error: sha256.h: No such file or directory
In file included from /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:206: error: expected ‘=’, ‘,’, ‘;’, ‘asm’ or ‘__attribute__’ before ‘archive_sha256_ctx’
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:363: error: expected ‘)’ before ‘*’ token
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:364: error: expected ‘;’ before ‘int’
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:667: error: expected ‘)’ before ‘*’ token
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:674: error: expected ‘)’ before ‘*’ token
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:682: error: expected ‘)’ before ‘*’ token
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1334: error: ‘__archive_libmd_sha256init’ undeclared here (not in a function)
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1335: error: ‘__archive_libmd_sha256update’ undeclared here (not in a function)
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1336: error: ‘__archive_libmd_sha256final’ undeclared here (not in a function)
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c: In function ‘main’:
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: ‘archive__ctx’ undeclared (first use in this function)
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: (Each undeclared identifier is reported only once
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: for each function it appears in.)
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: expected ‘;’ before ‘ctx’
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1439: error: ‘ctx’ undeclared (first use in this function)
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[1]: *** [CMakeFiles/cmTryCompileExec2397044773.dir/check_crypto_md.c.o] Error 1
make: *** [cmTryCompileExec2397044773/fast] Error 2

Source file was:

#define ARCHIVE_SHA256_COMPILE_TEST
#define ARCHIVE_CRYPTO_SHA256_LIBMD
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. OpenSSL
 * 6. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive__ctx ctx;
  archive__init(&ctx);
  archive__update(&ctx, *argv, argc);
  archive__final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_SHA512_LIBMD failed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1193203683/fast"
make -f CMakeFiles/cmTryCompileExec1193203683.dir/build.make CMakeFiles/cmTryCompileExec1193203683.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1193203683.dir/check_crypto_md.c.o
/usr/bin/gcc   -w   -I/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Utilities/cmlibarchive/libarchive -I/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec1193203683.dir/check_crypto_md.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:103:20: error: sha512.h: No such file or directory
In file included from /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:244: error: expected ‘=’, ‘,’, ‘;’, ‘asm’ or ‘__attribute__’ before ‘archive_sha512_ctx’
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:369: error: expected ‘)’ before ‘*’ token
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:370: error: expected ‘;’ before ‘int’
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1081: error: expected ‘)’ before ‘*’ token
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1088: error: expected ‘)’ before ‘*’ token
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1096: error: expected ‘)’ before ‘*’ token
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1408: error: ‘__archive_libmd_sha512init’ undeclared here (not in a function)
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1409: error: ‘__archive_libmd_sha512update’ undeclared here (not in a function)
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1410: error: ‘__archive_libmd_sha512final’ undeclared here (not in a function)
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c: In function ‘main’:
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: ‘archive__ctx’ undeclared (first use in this function)
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: (Each undeclared identifier is reported only once
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: for each function it appears in.)
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: expected ‘;’ before ‘ctx’
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:1439: error: ‘ctx’ undeclared (first use in this function)
make[1]: *** [CMakeFiles/cmTryCompileExec1193203683.dir/check_crypto_md.c.o] Error 1
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
make: *** [cmTryCompileExec1193203683/fast] Error 2

Source file was:

#define ARCHIVE_SHA512_COMPILE_TEST
#define ARCHIVE_CRYPTO_SHA512_LIBMD
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. OpenSSL
 * 6. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive__ctx ctx;
  archive__init(&ctx);
  archive__update(&ctx, *argv, argc);
  archive__final(&ctx, NULL);
  return 0;
}

Determining size of unsigned short passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2606526566/fast"
make -f CMakeFiles/cmTryCompileExec2606526566.dir/build.make CMakeFiles/cmTryCompileExec2606526566.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2606526566.dir/CMAKE_SIZEOF_UNSIGNED_SHORT.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec2606526566.dir/CMAKE_SIZEOF_UNSIGNED_SHORT.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CheckTypeSize/CMAKE_SIZEOF_UNSIGNED_SHORT.c
Linking C executable cmTryCompileExec2606526566
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2606526566.dir/link.txt --verbose=1
/usr/bin/gcc         CMakeFiles/cmTryCompileExec2606526566.dir/CMAKE_SIZEOF_UNSIGNED_SHORT.c.o  -o cmTryCompileExec2606526566 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if the function wsyncup exists in the /usr/lib/libcurses.so passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3031499518/fast"
make -f CMakeFiles/cmTryCompileExec3031499518.dir/build.make CMakeFiles/cmTryCompileExec3031499518.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3031499518.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -DCHECK_FUNCTION_EXISTS=wsyncup   -o CMakeFiles/cmTryCompileExec3031499518.dir/CheckFunctionExists.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec3031499518
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3031499518.dir/link.txt --verbose=1
/usr/bin/gcc     -DCHECK_FUNCTION_EXISTS=wsyncup    CMakeFiles/cmTryCompileExec3031499518.dir/CheckFunctionExists.c.o  -o cmTryCompileExec3031499518 -rdynamic -lcurses 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if the include file elf.h exists passed with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1963987677/fast"
make -f CMakeFiles/cmTryCompileExec1963987677.dir/build.make CMakeFiles/cmTryCompileExec1963987677.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1963987677.dir/CheckIncludeFile.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec1963987677.dir/CheckIncludeFile.c.o   -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckIncludeFile.c
Linking C executable cmTryCompileExec1963987677
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1963987677.dir/link.txt --verbose=1
/usr/bin/gcc         CMakeFiles/cmTryCompileExec1963987677.dir/CheckIncludeFile.c.o  -o cmTryCompileExec1963987677 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'


Looking for a Fortran compiler passed with the following output:
-- The Fortran compiler identification is GNU
-- Check for working Fortran compiler: /usr/bin/f95
-- Check for working Fortran compiler: /usr/bin/f95  -- works
-- Detecting Fortran compiler ABI info
-- Detecting Fortran compiler ABI info - done
-- Checking whether /usr/bin/f95 supports Fortran 90
-- Checking whether /usr/bin/f95 supports Fortran 90 -- yes
-- Configuring done
-- Generating done
-- Build files have been written to: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/Tests/CMakeFiles/CheckFortran

Performing C++ SOURCE FILE Test run_pic_test succeded with the following output:
Change Dir: /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1866133144/fast"
make -f CMakeFiles/cmTryCompileExec1866133144.dir/build.make CMakeFiles/cmTryCompileExec1866133144.dir/build
make[1]: Entering directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec1866133144.dir/src.cxx.o
/usr/bin/g++    -Drun_pic_test   -fPIE -o CMakeFiles/cmTryCompileExec1866133144.dir/src.cxx.o -c /mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp/src.cxx
Linking CXX executable cmTryCompileExec1866133144
/mnt/oqtansTools/oqtans_src/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1866133144.dir/link.txt --verbose=1
/usr/bin/g++      -Drun_pic_test    CMakeFiles/cmTryCompileExec1866133144.dir/src.cxx.o  -o cmTryCompileExec1866133144 -rdynamic 
make[1]: Leaving directory `/mnt/oqtansTools/oqtans_src/cmake-2.8.9/CMakeFiles/CMakeTmp'

Source file was:
int main() { return 0;}
